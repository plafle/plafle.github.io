<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2025/01/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>2023.8.23</title>
    <url>/2023/08/23/2023.8.23/</url>
    <content><![CDATA[<p><span
class="math inline">\(\hspace{1cm}\)</span>设想在一条道路上随机选择一个位置，然后降落到这个位置。</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>接着你测量从这个位置到道路开始位置的距离（记为l1），以及从这个位置到道路结束位置的距离（记为l2)。</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>如果这条道路是无限长的，那么我们可以断言，l1和l2都是无穷大的概率为1</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>反过来说，如果l1或l2中的一个是有限的，那么我们可以断言，这条道路长度是有限的的概率是1</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>我的出生就好似在人类的历史进程中随机选择了一个时间降生</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>从人类出现到我出生所经过的时间好比上文中的l1，从我出生到人类灭绝所经过的时间好比上文中的l2</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>我无从得知l2是多少，但是我目前可以明确：l1是有限的</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>所以我可以得到推论：人类的历史极大可能是有限的，人类最终会灭绝的概率是1。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>初学微分の笔记</title>
    <url>/2023/06/21/%E5%88%9D%E5%AD%A6%E5%BE%AE%E5%88%86%E3%81%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="微分总结">微分总结</h2>
<h3 id="极限导数连续性可导性">1.极限，导数，连续性，可导性</h3>
<p><span class="math display">\[
\lim_{x \to a}f(x) = L
\]</span></p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>这个式子叫做函数<span
class="math inline">\(f\)</span>在<span
class="math inline">\(a\)</span>处的双侧极限，表示对于任意的<span
class="math inline">\(\varphi&gt;0\)</span>，可以选取对应的<span
class="math inline">\(\beta &gt; 0\)</span>，使得对于所有满足<span
class="math inline">\(0 &lt; |x - a| &lt; \beta\)</span>的<span
class="math inline">\(x\)</span>，都有<span class="math inline">\(|f(x)
- L| &lt; \varphi\)</span>.</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>除了双侧极限，我们还有左侧极限和右侧极限。
<span class="math display">\[
\lim_{x \to a^-}f(x) = L
\]</span></p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>这个式子叫做函数<span
class="math inline">\(f\)</span>在<span
class="math inline">\(a\)</span>处的左侧极限，表示对于任意的<span
class="math inline">\(\varphi&gt;0\)</span>，可以选取对应的<span
class="math inline">\(\beta &gt; 0\)</span>，使得对于所有满足<span
class="math inline">\(0 &lt; a - x &lt; \beta\)</span>的<span
class="math inline">\(x\)</span>，都有<span class="math inline">\(|f(x)
- L| &lt; \varphi\)</span>.</p>
<p>同时： <span class="math display">\[
\lim_{x \to a^+}f(x) = L
\]</span></p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>这个式子叫做函数<span
class="math inline">\(f\)</span>在<span
class="math inline">\(a\)</span>处的右侧极限，表示对于任意的<span
class="math inline">\(\varphi&gt;0\)</span>，可以选取对应的<span
class="math inline">\(\beta &gt; 0\)</span>，使得对于所有满足<span
class="math inline">\(0 &lt; x - a &lt; \beta\)</span>的<span
class="math inline">\(x\)</span>，都有<span class="math inline">\(|f(x)
- L| &lt; \varphi\)</span>.</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>极限不一定存在，比如<span
class="math inline">\(f(x) = sin(\frac1x)\)</span>在<span
class="math inline">\(x = 0\)</span>处就没有极限。</p>
<ul>
<li><p>三明治定理：</p>
<p>如果对于所有在<span class="math inline">\(a\)</span>附近的<span
class="math inline">\(x\)</span>都满足<span class="math inline">\(g(x)
\le f(x) \le h(x)\)</span>，且</p>
<p><span class="math display">\[
\lim_{x \to a}g(x) = L = \lim_{x \to a}h(x)
\]</span></p></li>
</ul>
<p><span class="math inline">\(\hspace{1cm}\)</span>那么有 <span
class="math display">\[
  \lim_{x \to a}f(x) = L
\]</span></p>
<ul>
<li><p>连续性</p>
<p>若<span class="math inline">\(x\)</span>在函数<span
class="math inline">\(f\)</span>的定义域内，函数<span
class="math inline">\(f\)</span>在<span
class="math inline">\(x\)</span>处存在双侧极限，且双侧极限等于<span
class="math inline">\(f(x)\)</span>，则函数<span
class="math inline">\(f\)</span>在<span
class="math inline">\(x\)</span>处连续。</p></li>
<li><p>导数</p>
<p>函数<span class="math inline">\(f\)</span>在<span
class="math inline">\(x\)</span>处的导数<span
class="math inline">\(f&#39;(x)\)</span>定义为： <span
class="math display">\[
f&#39;(x) = \lim_{h\to x}\frac{f&#39;(x + h) - f&#39;(x)}{h}
\]</span> 同时我们也可以用<span
class="math inline">\(\frac{dy}{dx}\)</span>来表示函数<span
class="math inline">\(f\)</span>在<span
class="math inline">\(x\)</span>处的导数。其中<span
class="math inline">\(dx\)</span>表示<span
class="math inline">\(x\)</span>变化很小一个范围，<span
class="math inline">\(dy\)</span>表示此时<span
class="math inline">\(y\)</span>对应的变化量。</p></li>
<li><p>可导性</p>
<p>函数<span class="math inline">\(f\)</span>在<span
class="math inline">\(x\)</span>处可导，当且仅当函数<span
class="math inline">\(f\)</span>在<span
class="math inline">\(x\)</span>处连续，且函数<span
class="math inline">\(f\)</span>在<span
class="math inline">\(x\)</span>处的“左导数”和“右导数”相等，其中： <span
class="math display">\[
左导数= \lim_{h \to x ^-} \frac{f&#39;(x + h) - f&#39;(x)}{h}
\]</span></p>
<p><span class="math display">\[
右导数 = \lim_{h \to x^+}\frac{f&#39;(x + h) - f&#39;(x)}{h}
\]</span></p></li>
</ul>
<h3 id="用更好的方法求导">2.用更好的方法求导</h3>
<ul>
<li><p>加/减法法则：</p>
<p>若<span class="math inline">\(f(x) = g(x) \pm h(x)\)</span>，则<span
class="math inline">\(f&#39;(x) = g&#39;(x) \pm
h&#39;(x)\)</span></p></li>
<li><p>乘法法则： <span class="math display">\[
\frac{d}{dx}(uv) = \frac{du}{dx}v + \frac{dv}{dx}u
\]</span></p></li>
<li><p>乘积法则的推广 <span class="math display">\[
\frac{d}{dx}(uvw) = \frac{du}{dx}vw + \frac{dv}{dx}uw + \frac{dw}{dx}uv
\]</span></p></li>
<li><p>除法法则：</p>
<p>若<span class="math inline">\(f(x) =
\frac{g(x)}{h(x)}\)</span>，则有： <span class="math display">\[
f&#39;(x) = \frac{g&#39;(x)h(x) - g(x)h&#39;(x)}{(h(x))^2}
\]</span></p></li>
<li><p>链式求导法则：</p>
<p>若<span class="math inline">\(u\)</span>是<span
class="math inline">\(v\)</span>的函数，<span
class="math inline">\(v\)</span>是<span
class="math inline">\(s\)</span>的函数，则有： <span
class="math display">\[
\frac{du}{ds} = \frac{du}{dv}\frac{dv}{ds}
\]</span></p></li>
</ul>
<h3 id="三角函数的导数与极限">3.三角函数的导数与极限</h3>
<p><span
class="math inline">\(\hspace{1cm}\)</span>首先有一个基本的定理（这里暂且不证）：
<span class="math display">\[
\lim_{x \to 0} \frac{sin(x)}{x} = 1
\]</span> <span
class="math inline">\(\hspace{1cm}\)</span>然后先看一个极限： <span
class="math display">\[
\lim_{x \to 0} \frac{cos(x) - 1}{x} = \lim_{x \to 0} \frac{cos^2(x) -
1}{x \cdot (cos(x) + 1)} = \lim_{x \to 0} \frac{-sin^2(x)}{x \cdot
(cos(x) + 1)} \\= \lim_{x \to 0}\frac{sin(x)}x \times (-sin(x))
\times\frac{1}{cos(x) + 1} = (1) \times (0)\times (\frac12) = 0
\]</span></p>
<p><span class="math inline">\(\hspace{1cm}\)</span>接下来求<span
class="math inline">\(f(x) = sin(x)\)</span>的导数： <span
class="math display">\[
f&#39;(x) = \lim_{h \to x} \frac{sin(x + h) - sin(x)}{h} = \lim_{h \to
x} \frac{sin(x)cos(h) + cos(x)sin(h) - sin(x)}{h} \\ = \lim_{h \to x}
\frac{sin(x) \cdot (cos(h) - 1)}h + \lim_{h \to x}\frac{sin(h)}h \cdot
cos(x) \\=\lim_{h\to x}\frac{cos(x) - 1}{h} \times sin(x ) + (1)\cdot
cos(x) = (0 )\times sin(x) + cos(x) \times(1) = cos(x)
\]</span> <span
class="math inline">\(\hspace{1cm}\)</span>同理，我们可以得到<span
class="math inline">\(f(x) = cos(x)\)</span>的导数： <span
class="math display">\[
f&#39;(x) = -\sin(x)
\]</span> <span
class="math inline">\(\hspace{1cm}\)</span>根据这两个公式，我们可以通过乘积法则和除法法则求出<span
class="math inline">\(f(x) = tan(x)，f(x) = csc(x)\)</span>,<span
class="math inline">\(f(x) = sec(x),f(x) = cot(x)\)</span>的导数. <span
class="math display">\[
\frac d{dx}(tan(x)) = sec^2(x)\\\frac d{dx}(sec(x)) = sec(x)tan(x)\\
\frac d{dx}(csc(x)) = -csc(x)cot(x) \\ \frac{d}{dx}(cot(x)) = -csc^2(x)
\]</span></p>
<h3 id="关于e">4.关于e</h3>
<p><span class="math inline">\(\hspace{1cm}\)</span>自然常数<span
class="math inline">\(e\)</span>的定义： <span class="math display">\[
e = \lim_{n \to \infty}(1 + \frac1n)^n
\]</span> <span
class="math inline">\(\hspace{1cm}\)</span>这样做会有一个风险，那就是这个极限不一定存在。现在我们暂且不管。</p>
<p><span class="math inline">\(\hspace{1cm}\)</span>对于<span
class="math inline">\(e\)</span>的收敛性证明，我们证一个<span
class="math inline">\(e \le 4\)</span>即可。即我们尝试证明： <span
class="math display">\[
(1 + \frac1n)^n \le 4
\]</span> <span class="math inline">\(\hspace{1cm}\)</span>即要证明：
<span class="math display">\[
\sqrt[n]{\frac14} \leq \frac{n}{n + 1}
\]</span> <span
class="math inline">\(\hspace{1cm}\)</span>根据均值不等式，我们有 <span
class="math display">\[
\sqrt[n]{\frac14} = \sqrt[n]{\frac12 \times \frac{1}{2} \times 1^{n -
2}} \le \frac{n - 1}n \le \frac n{n + 1}
\]</span> <span class="math inline">\(\hspace{1cm}\)</span>因此得证<span
class="math inline">\(e \le 4\)</span>.</p>
<p>​</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>然后我们来求一个极限： <span
class="math display">\[
\lim _{n \to \infty}(1 + \frac rn)^n
\]</span> <span class="math inline">\(\hspace{1cm}\)</span>令<span
class="math inline">\(k = \frac nr\)</span>，则<span
class="math inline">\(n = rk\)</span>，所以有： <span
class="math display">\[
\lim _{n \to \infty}(1 + \frac rn)^n = \lim_{n \to \infty} (1 +
\frac1k)^{rk} = \lim_{n \to \infty}((1 + \frac1k)^k)^r = e^r
\]</span></p>
<h3 id="对数函数和指数函数的导数">5.对数函数和指数函数的导数</h3>
<p><span
class="math inline">\(\hspace{1cm}\)</span>先来求对数函数的导数，设<span
class="math inline">\(f(x) = \log_bx\)</span>，则有： <span
class="math display">\[
f&#39;(x) = \lim_{h \to 0} \frac{\log_b(x + h) - \log_bx} h = \lim_{h
\to 0} \frac{\log_b(\frac{x + h}{x})}h = \lim_{h \to 0}\log_b(1 + \frac
hx) ^ \frac1h = \lim_{h \to \infty} \log_b(1 + \frac 1h \times \frac1x
)^h = \log_b e^\frac1x = \frac{1}{x \times ln(b)}
\]</span></p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>再来看指数函数的导数。设<span
class="math inline">\(y = b^x\)</span>，则<span class="math inline">\(x
= \log_by\)</span>，所以 <span class="math display">\[
\frac{dx}{dy} = \frac1{y \times ln(b)}
\]</span> <span class="math inline">\(\hspace{1cm}\)</span>则： <span
class="math display">\[
\frac{dy}{dx} = yln(b) = b^xln(b)
\]</span></p>
<h3 id="对y-fxgx求导">6.对<span class="math inline">\(y =
f(x)^{g(x)}\)</span>求导</h3>
<p><span
class="math inline">\(\hspace{1cm}\)</span>一个例子胜千言。比如我们现在要对<span
class="math inline">\(y = x^x\)</span>求导。</p>
<p><span class="math inline">\(\hspace{1cm}\)</span>有： <span
class="math display">\[
ln(y) = xln(x) \\ \frac d{dx} ln(y) = \frac d{dx} (x ln(x)) \\ \frac
d{dy}(ln(y)) \times \frac{dy}{dx} = ln(x) + 1 \\ \frac1y \times
\frac{dy}{dx} = ln(x) + 1 \\ \frac{dy}{dx} = (ln(x) + 1) \times x^x
\]</span> <span
class="math inline">\(\hspace{1cm}\)</span>我们再举一个例子，这个例子推出的结论也是很重要的一个结论。我们现在要求<span
class="math inline">\(y = x^a\)</span>的导数。</p>
<p><span class="math inline">\(\hspace{1cm}\)</span>有： <span
class="math display">\[
ln(y) = aln(x) \\ \frac d{dx}(ln(y)) = \frac {d}{dx}(aln(x)) \\ \frac
d{dy}(ln(y)) \times \frac{dy}{dx} = \frac ax \\ \frac{dy}{dx} = \frac ax
\times y = \frac ax \times x^a = ax^{a - 1}
\]</span></p>
<h3 id="指数增长和指数衰变">7.指数增长和指数衰变</h3>
<ul>
<li>指数增长</li>
</ul>
<p><span class="math inline">\(\hspace{1cm}\)</span>假设<span
class="math inline">\(y = Ae^{kx}\)</span>，则<span
class="math inline">\(\frac{dy}{dx} =
Ake^{kx}\)</span>。这说明该函数的增长速度和函数值成正比。</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>这很符合现实中的一些情况。一个生物种群，它扩张繁殖的速度和这个生物种群内生物的多少成正比。</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>让我们来解决一个问题。一个兔子种群现在有1000只兔子，而3年后增长到64000只，那么4年后会有多少兔子呢？</p>
<p><span class="math inline">\(\hspace{1cm}\)</span>设<span
class="math inline">\(f(x)\)</span>表示兔子种群在第<span
class="math inline">\(x\)</span>年有<span
class="math inline">\(f(x)\)</span>只兔子，那么我们有<span
class="math inline">\(f(0) = 1000\)</span>,<span
class="math inline">\(f(3) = 64000\)</span>.</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>根据指数增长的原则，我们设<span
class="math inline">\(f(x) = Ae^{kx}\)</span>,则<span
class="math inline">\(f(0) = Ae^0\)</span>,则<span
class="math inline">\(A = f(0)\)</span>.</p>
<p><span class="math inline">\(\hspace{1cm}\)</span>所以我们有<span
class="math inline">\(f(x) = f(0)e^{kx} = 1000e^{kx}\)</span>,则<span
class="math inline">\(f(3) = 1000e^{3k} = 64000\)</span>，所以<span
class="math inline">\(e^{3k} = 64\)</span>，<span
class="math inline">\(3k = ln(64)\)</span>，<span
class="math inline">\(k = \frac{ln(64)}3 = \ln(4)\)</span>，所以<span
class="math inline">\(f(x) = 1000e^{\ln(4)x}\)</span>。将<span
class="math inline">\(x = 4\)</span>代入，有$f(4) = 1000e^{(4) } = 1000e
^ {(256)} = 256000 $.所以4年后有256000只兔子。</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>同时我们也可以得到，一般对于这种建模，我们都有<span
class="math inline">\(f(t) = f(0)e^{kt}\)</span>，</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>可以从上述例子中看出，指数函数增长得很快。所以我们推测出一下定理（可用洛必达法则证明）：
<span class="math display">\[
\lim_{x\to \infty} \frac{f(x)}{b^x} = 0,其中f(x)是关于x的多项式，b &gt;
1
\]</span></p>
<ul>
<li>指数衰减</li>
</ul>
<p><span
class="math inline">\(\hspace{1cm}\)</span>指数衰减适用于给原子衰变建模。因为原子越多，其衰变速度越快。换句话说，衰变速度与原子个数成正比。</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>现在假设你有一瓶铀—235，它的半衰期是7年，也就是说过7年你打开这个瓶子，你会发现这个瓶子里面只有一半铀-235了。如果你初始又50公斤的铀-235，那么过10年之后你还有几公斤的铀-235没有衰变呢？</p>
<p><span class="math inline">\(\hspace{1cm}\)</span>设<span
class="math inline">\(f(t)\)</span>是时间为<span
class="math inline">\(t\)</span>时你剩下的铀-235，那我们应该有： <span
class="math display">\[
  f&#39;(t) = -kf(t),其中k为常数
\]</span> <span
class="math inline">\(\hspace{1cm}\)</span>所以我们设<span
class="math inline">\(f(t) = Ae^{-kt}\)</span>，则<span
class="math inline">\(f(0) = Ae^0 = A = 50\)</span>，所以<span
class="math inline">\(f(t) = 50e^{-kt}\)</span>。又因为<span
class="math inline">\(f(7) = 50e^{-7k} = 25\)</span>，所以<span
class="math inline">\(-7k = ln(\frac 12) = \ln(1) - \ln(2) =
-\ln(2)\)</span>，所以<span class="math inline">\(k = \frac{\ln
2}7\)</span>，<span class="math inline">\(f(t) = 50e^{\frac{-t
\ln2}7}\)</span>。当<span class="math inline">\(t = 10\)</span>时，<span
class="math inline">\(f(10) = 50e^{\frac{-10 \ln2}7}\)</span>。</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>同时我们也可以得到，一般对于这种建模，我们都有<span
class="math inline">\(f(t) = f(0)e^{-kt}\)</span>，同时<span
class="math inline">\(k = \frac{\ln2}{t_{1/2}}\)</span>，其中<span
class="math inline">\(t_{1 / 2}\)</span>表示半衰期时间。</p>
<p><span
class="math inline">\(\hspace{1cm}\)</span>和指数增长那一块一样，我们会得出几个有关极限的结论：</p>
<ul>
<li>对数函数在<span
class="math inline">\(\infty\)</span>附近增长缓慢：</li>
</ul>
<p><span class="math display">\[
  \lim_{x \to \infty} \frac{\log_b x}{f(x)} =
0,其中f(x)是关于x的多项式,b &gt; 1
\]</span></p>
<ul>
<li>对数函数在<span class="math inline">\(0\)</span>附近增长缓慢： <span
class="math display">\[
\lim_{x \to 0}f(x)\cdot \log_bx = 0,其中f(x)是关于x的多项式,b &gt; 1
\]</span></li>
</ul>
<p><span class="math inline">\(\hspace{1cm}\)</span> 当<span
class="math inline">\(f(x) = x\)</span>时关于上面这个极限的证明： <span
class="math display">\[
    \lim_{x \to 0}x\cdot \log_bx = \lim_{x \to \infty}\frac 1x \cdot
\log_b(\frac 1x) = \lim_{x \to \infty} \frac{-\log_bx}{x} = 0
    \]</span></p>
<h3 id="双曲函数">8.双曲函数</h3>
<p>定义： <span class="math display">\[
sinh(x) = \frac{e^x - e^{-x}}2 \\ cosh(x) = \frac {e^x + e^{-x}}2
\\tanh(x) = \frac{sinh(x)}{cosh(x)} \\ csch(x) = \frac1{sinh(x)} \\
sech(x) = \frac1{cosh(x)} \\ coth(x) = \frac1{tanh(x)}
\]</span> 注意到 <span class="math display">\[
cosh^2(x) - sinh^2(x) = 1
\]</span> 如果对其求导，会得到： <span class="math display">\[
\frac d{dx}(sinh(x)) =\frac d{dx}(\frac{e^x - e^{-x}}2) = \frac{e^x +
e^{-x}}2 = cosh(x)
\]</span></p>
<p><span class="math display">\[
\frac d{dx}(cosh(x)) =\frac d{dx}(\frac{e^x + e^{-x}}2) = \frac{e^x -
e^{-x}}2 = sinh(x)
\]</span></p>
<p>这也是其前缀<span class="math inline">\(sin\)</span>，<span
class="math inline">\(cos\)</span>的原因。</p>
<p>不管怎样，你可以通过链式求导或除法法则得到如下结果： <span
class="math display">\[
\frac{d}{dx}(tanh(x)) = sech^2(x)\\\frac d{dx}(sech(x)) =
-sech(x)tanh(x)\\ \frac d{dx}(csch(x)) = -csch(x)coth(x) \\
\frac{d}{dx}(coth(x)) = -csch^2(x)
\]</span>
注意到它们与三角函数导数之间的关系（事实上，这段公式是我从三角函数那里复制下来再轻微改造得到的）。</p>
<p>顺便说一句，<span
class="math inline">\(cosh(x)\)</span>的图像就是悬链线的图像，悬链线就是一个固定绳子的两段，在重力场中让它自然垂下，绳子的曲线方程.</p>
<h3 id="反函数">9.反函数</h3>
<p>函数本质是一个映射。一个元素<span
class="math inline">\(x\)</span>经过函数<span
class="math inline">\(f\)</span>的映射后就变成了元素<span
class="math inline">\(f(x)\)</span>，那么将<span
class="math inline">\(f(x)\)</span>变回<span
class="math inline">\(x\)</span>的映射就叫做函数<span
class="math inline">\(f\)</span>的反函数，记为<span
class="math inline">\(f^{-1}\)</span>,也就是<span
class="math inline">\(f^{-1}(f(x)) = x\)</span>。</p>
<p>一个函数<span class="math inline">\(f\)</span>如果要有反函数<span
class="math inline">\(f^{-1}\)</span>，要满足对于每一个<span
class="math inline">\(y\)</span>，最多只有一个<strong>定义域内</strong>的<span
class="math inline">\(x\)</span>使得<span class="math inline">\(f(x) =
y\)</span>.</p>
<p>对于一个函数<span class="math inline">\(f\)</span>，如果<span
class="math inline">\(f&#39;(x)\)</span>恒大于等于0，且只有有限多个<span
class="math inline">\(x\)</span>使得<span
class="math inline">\(f&#39;(x) = 0\)</span>，那么显然<span
class="math inline">\(f\)</span>存在反函数。同样的，对于一个函数<span
class="math inline">\(f\)</span>，如果<span
class="math inline">\(f&#39;(x)\)</span>恒小于等于0，且只有有限多个<span
class="math inline">\(x\)</span>使得<span
class="math inline">\(f&#39;(x) = 0\)</span>，那么显然<span
class="math inline">\(f\)</span>也存在反函数。</p>
<p>如果我们现在已经知道<span class="math inline">\(f(x)\)</span>和<span
class="math inline">\(f&#39;(x)\)</span>，如何求<span
class="math inline">\(f^{-1}(x)\)</span>的导数呢？</p>
<p>首先如果<span class="math inline">\(y = f^{-1}(x)\)</span>，那么
<span class="math display">\[
x =f(y) \\ \frac{dx}{dy} = \frac{d}{dy}(f(y)) \\ \frac{dx}{dy}
=  f&#39;(y) \\ \frac{dy}{dx} = \frac 1{f&#39;(y)}
\]</span></p>
<p>所以我们得到了反函数的导数。</p>
<p>特别的，反函数的图像与原函数的图像关于<span class="math inline">\(y =
x\)</span>对称。</p>
<h3 id="再谈导数">10.再谈导数</h3>
<p>导数是一个很强大的工具，所以我们重新来挖掘一下它的潜在价值。</p>
<p>一阶导数<span
class="math inline">\(f&#39;(x)\)</span>表现的是函数<span
class="math inline">\(f\)</span>的增减性。<span
class="math inline">\(f&#39;(x) &gt; 0\)</span>则函数在x上增长，<span
class="math inline">\(f&#39;(x) &lt; 0\)</span>则函数在x上减少。</p>
<p>二阶导数<span
class="math inline">\(f&#39;&#39;(x)\)</span>表现得是函数<span
class="math inline">\(f\)</span>的凹凸性。<span
class="math inline">\(f&#39;&#39;(x) &gt;
0\)</span>则函数在x处凹面向上，<span
class="math inline">\(f&#39;&#39;(x) &lt;
0\)</span>则函数在x处凹面向下。函数<span
class="math inline">\(f\)</span>的凹凸性质改变的临界点叫做函数<span
class="math inline">\(f\)</span>的拐点。在拐点<span
class="math inline">\(x\)</span>上，必定有<span
class="math inline">\(f&#39;&#39;(x) = 0\)</span>.</p>
<p>有一个不证自明的事实。函数<span
class="math inline">\(f\)</span>的最大值/最小值只会是<span
class="math inline">\(f(x)\)</span>，其中的<span
class="math inline">\(x\)</span>满足<span
class="math inline">\(f&#39;(x) = 0\)</span>或<span
class="math inline">\(f&#39;(x)\)</span>不存在或<span
class="math inline">\(x\)</span>是闭区间的端点.</p>
<p>现在我们的任务是求某一个函数的最值。比如说<span
class="math inline">\(f(x) = x^2 - 2x
+2\)</span>，通过配方它有最小值1。但如果我们以导数的视角，你就会先对其求导得到<span
class="math inline">\(f&#39;(x) = 2x - 2\)</span>，那么<span
class="math inline">\(f&#39;(x)\)</span>的零点是1。而<span
class="math inline">\(f&#39;&#39;(x) = 2 &gt;
0\)</span>，所以函数凹面向上，<span class="math inline">\(f(1) =
1\)</span>是函数<span class="math inline">\(f\)</span>的最小值。</p>
<p>上面这个例子不能体现处导数求极值的优越性，让我们再来看一个栗子。</p>
<blockquote>
<p>求函数<span class="math inline">\(f(x) = 5x \sqrt{900 -
6x}\)</span>的最大值。</p>
</blockquote>
<p>对其求导，得到<span class="math inline">\(f&#39;(x) = \frac{45(100 -
x)}{\sqrt{900 -
6x}}\)</span>。导数函数的零点为100。导数函数只有这一个零点，说明这一定是最大值或者最小值。让我们再看一下，对于任意的<span
class="math inline">\(f&#39;(v)(v &lt; 100)\)</span>都有<span
class="math inline">\(f&#39;(v) &gt; 0\)</span>，对于任意的<span
class="math inline">\(f&#39;(w)(w &gt; 100)\)</span>都有<span
class="math inline">\(f&#39;(w) &lt; 0\)</span>。所以<span
class="math inline">\(f(100) = 5000
\sqrt{3}\)</span>是函数的最大值。</p>
<h3 id="一些定理以及推论">11.一些定理以及推论</h3>
<ul>
<li><p>罗尔定理</p>
<p>若函数<span class="math inline">\(f\)</span>在闭区间<span
class="math inline">\([a,b]\)</span>间连续，在开区间<span
class="math inline">\((a,b)\)</span>间可导，如果<span
class="math inline">\(f(a) = f(b)\)</span>，则在开区间<span
class="math inline">\((a,b)\)</span>中必定存在一点<span
class="math inline">\(c\)</span>，满足<span
class="math inline">\(f&#39;(c) = 0\)</span>.</p></li>
<li><p>拉格朗日中值定理</p>
<p>若函数<span class="math inline">\(f\)</span>在闭区间<span
class="math inline">\([a,b]\)</span>间连续，在开区间<span
class="math inline">\((a,b)\)</span>间可导，则在开区间<span
class="math inline">\((a,b)\)</span>中必定存在一点<span
class="math inline">\(c\)</span>，满足<span
class="math inline">\(f&#39;(c) = \frac{f(b) - f(a)}{b -
a}\)</span>。</p></li>
<li><p>拉格朗日中值定理的推论</p>
<p>如果一个函数<span class="math inline">\(f\)</span>的导函数<span
class="math inline">\(f&#39;\)</span>对于定义域内的任意<span
class="math inline">\(x\)</span>满足<span
class="math inline">\(f&#39;(x) = 0\)</span>，则函数<span
class="math inline">\(f\)</span>为常数函数。</p></li>
</ul>
<p>证明：固定其定义域内一点<span
class="math inline">\(s\)</span>，设<span class="math inline">\(f(s) =
C\)</span>。再任取其定义域内一点<span
class="math inline">\(t\)</span>，因为导函数恒为0，所以<span
class="math inline">\(\frac{f(s) - f(t)}{s - t} = 0\)</span>，所以<span
class="math inline">\(f(s) = f(t) =
C\)</span>，所以对于定义域内任意一点<span
class="math inline">\(t\)</span>，都有<span class="math inline">\(f(t) =
C\)</span>。所以函数<span
class="math inline">\(f\)</span>为常数函数。</p>
<h3 id="线性化">12.线性化</h3>
<blockquote>
<p>估算<span class="math inline">\(\sqrt{11}\)</span>.</p>
</blockquote>
<p>这里的方法（线性化）是先将其函数化，将原问题转化为对于函数<span
class="math inline">\(f(x) = \sqrt{x}\)</span>，求<span
class="math inline">\(f(11)\)</span>.</p>
<p>然后我们找一个离<span
class="math inline">\(11\)</span>很近且很好求的<span
class="math inline">\(f(x)\)</span>，比如<span
class="math inline">\(f(9)\)</span>。求出<span
class="math inline">\(f&#39;(9) = \frac
16\)</span>。我们记通过（9，3）的切线为<span
class="math inline">\(L\)</span>，有<span class="math inline">\(L =
\frac 16 x + \frac 32\)</span>，则<span class="math inline">\(L(11) =
\frac {10} 3\)</span>。我们估算出来的值为<span
class="math inline">\(\frac{10}3\)</span>.</p>
<p>这里我们得到近似公式： <span class="math display">\[
f(x) \approx L(x) = f(a) + f&#39;(a)(x - a)
其中a是你选择的一个离x较近的且好算的值
\]</span> 同时观察可得：</p>
<ul>
<li><p>如果<span
class="math inline">\(f&#39;&#39;\)</span>在a和x之间为<strong>正</strong>，则通过线性化得到的估算是<strong>低估</strong>。</p></li>
<li><p>如果<span
class="math inline">\(f&#39;&#39;\)</span>在a和x之间为<strong>负</strong>，则通过线性化得到的估算是<strong>高估</strong>。</p>
<p>同时我们对于误差也有一个很好的公式： <span class="math display">\[
误差 = \frac 12 f&#39;&#39;(c)(x - a)^2，其中c为在x和a之间的某个数。
\]</span></p></li>
</ul>
<h3 id="牛顿法">13.牛顿法</h3>
<p>牛顿法是用来估算函数零点（解方程）的方法。</p>
<p>一图胜千言</p>
<p>其中<span class="math inline">\(x^*\)</span>是真正的零点，<span
class="math inline">\(x_k\)</span>是估算的点，<span
class="math inline">\(x_{k + 1}\)</span>是更好的估算的点。</p>
<p>牛顿法只在一般情况下适用。在某些特殊情况下牛顿法不适用。</p>
<h3 id="洛必达法则">14.洛必达法则</h3>
<ul>
<li><p><strong>A. <span class="math inline">\(\frac0 0\)</span>或 <span
class="math inline">\(\frac{ \pm \infty}{\pm
\infty}\)</span>形：</strong></p>
<p>对于极限<span class="math inline">\(\lim_{x \to a}
\frac{g(x)}{h(x)}\)</span>，如果<span class="math inline">\(g(a) = h(a)
= 0\)</span>或<span class="math inline">\(g(a) = \pm
\infty\)</span>,<span class="math inline">\(h(a) = \pm
\infty\)</span>，那么：</p></li>
</ul>
<p><span class="math display">\[
\lim_{x \to a} \frac{g(x)}{h(x)} = \lim_{x \to a}
\frac{g&#39;(x)}{h&#39;(x)}
\]</span></p>
<ul>
<li><p><strong>B. <span class="math inline">\(0 \times  \pm
\infty\)</span></strong>形：</p>
<p>对于极限<span class="math inline">\(\lim_{x \to a}
{g(x)}{h(x)}\)</span>，如果<span class="math inline">\(g(a)  =0,h(a) =
\pm \infty\)</span>，则： <span class="math display">\[
\lim_{x \to a} {g(x)}{h(x)} = \lim_{x \to a} \frac{h(x)}{1 / g(x)}
\]</span> 因为<span class="math inline">\(g(a) = 0\)</span>，所以<span
class="math inline">\(\frac 1{g(a)}
=  \pm\infty\)</span>，此时可以用洛必达法则求解。</p></li>
<li><p><strong>C.<span class="math inline">\(\infty -
\infty\)</span>形：</strong></p>
<p>这种形式比较难处理，可以尝试同时乘以除以一个共轭根式，创造一个分母。</p>
<blockquote>
<p>求极限<span class="math inline">\(\lim_{x \to \infty}(\sqrt{x +
ln(x)} - \sqrt{x})\)</span>。</p>
</blockquote></li>
</ul>
<p><span class="math display">\[
\lim_{x \to \infty}(\sqrt{x + ln(x)} - \sqrt{x}) = \lim_{x \to \infty}
\frac{\ln x}{\sqrt{x + ln(x)} + \sqrt{x}}
\]</span></p>
<p>此时分数线上下的表达式均趋向于<span
class="math inline">\(\infty\)</span>，可以用洛必达法则求解。</p>
<ul>
<li><p><strong>D.<span class="math inline">\(1 ^ {\pm
\infty}，0^0,\infty ^ 0\)</span>形：</strong></p>
<p>这种形式最复杂。例如： <span class="math display">\[
求\lim_{x\to a}f(x)^{g(x)}
\]</span> 首先我们对其取对数： <span class="math display">\[
\lim_{x\to a}\ln(f(x)^{g(x)}) = \lim_{x\to a}g(x)\ln(f(x))
\]</span></p>
<p>这个时候如果该式子是不定式，我们可以用<span
class="math inline">\(B\)</span>类型对其求极限。如果不是，你需要另外想办法。</p>
<p>如果你求得了上面这个式子的极限，这时，就有： <span
class="math display">\[
\lim_{x\to a}\ln(f(x)^{g(x)}) = \lim_{x\to a}g(x)\ln(f(x)) = L \\ \lim
_{x \to a}f(x)^{g(x)} = e^L
\]</span></p></li>
</ul>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Three Formulae</title>
    <url>/2024/06/09/3formulae/</url>
    <content><![CDATA[<p><span class="math display">\[
\int\sqrt{a^2 - x^2}dx = \frac x2\sqrt{a^2 - x^2} + \frac
{a^2}2\arcsin(\frac xa) + C
\]</span> <span class="math display">\[
\int \frac 1{\sqrt{x^2 \pm a^2}}dx = \ln|x + \sqrt{x^2 \pm a^2}| + C
\]</span> <span class="math display">\[
\int \sqrt{x^2 \pm a^2}dx = \frac x2 \sqrt{x^2 \pm a^2} \pm\frac
{a^2}2\ln|x + \sqrt{x^2 \pm a^2}| + C
\]</span></p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>2024牛客D1</title>
    <url>/2024/08/25/2024%E7%89%9B%E5%AE%A2D1/</url>
    <content><![CDATA[<h3 id="a">A</h3>
<p>​ Given two integer <span class="math inline">\(n\)</span> and <span
class="math inline">\(m\)</span>, among all the sequence containing n
non-negative integers less than <span
class="math inline">\(2^m\)</span>, you need to count the number of such
sequences <span class="math inline">\(A\)</span> that there exists a
non-empty subsequence of <span class="math inline">\(A\)</span> in which
the bitwise AND of the integers is <span
class="math inline">\(1\)</span>.</p>
<p>​ Since the answer may be very large, output it modulo a positive
integer <span class="math inline">\(q\)</span>.</p>
<p><strong>Input</strong></p>
<p>​ The only line contains three integers <span
class="math inline">\(n,m,q\)</span>. (<span class="math inline">\(1 \le
n,m \le 5000, 1 \le q \le 10^9\)</span>)</p>
<p><strong>Output</strong></p>
<p>​ Output a line containing an integer, denoting the answer.</p>
<p><strong>Sample input 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 998244353</span><br></pre></td></tr></table></figure>
<p><strong>Sample output 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure>
<p><strong>Sample input 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5000 5000 998244353</span><br></pre></td></tr></table></figure>
<p><strong>Sample output 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2274146</span><br></pre></td></tr></table></figure>
<hr />
<p><strong>Solution</strong>:<a
href="https://www.bilibili.com/video/BV1MasWeiEs2/?spm_id_from=333.999.0.0&amp;vd_source=ad1b7dc4c298c14955ef2d4f1bcdb8b0">牛客2024D1TA_哔哩哔哩_bilibili</a></p>
<p><strong>Code</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> f(i,l,r) for (int i=l; i&lt;=r; i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,mo;</span><br><span class="line"><span class="type">int</span> C[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(i,<span class="number">1</span>,<span class="number">5000</span>)</span><br><span class="line">		C[i][i] = C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">f</span>(i,<span class="number">2</span>,<span class="number">5000</span>)</span><br><span class="line">		<span class="built_in">f</span>(j,<span class="number">1</span>,i - <span class="number">1</span>) &#123;</span><br><span class="line">			C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mo;			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">			(ans *= x) %= mo;</span><br><span class="line">		y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		(x *= x) %= mo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;mo;</span><br><span class="line">	<span class="built_in">pre</span>();</span><br><span class="line">	<span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> ans = <span class="built_in">ksm</span>(<span class="number">2</span>,n) - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (ans &lt; <span class="number">0</span>) ans += mo;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">f</span>(i,<span class="number">0</span>,n) &#123;</span><br><span class="line">		<span class="type">int</span> tmp = <span class="built_in">ksm</span>(<span class="built_in">ksm</span>(<span class="number">2</span>,i) - <span class="number">1</span>,m - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) tmp += mo;</span><br><span class="line">		<span class="type">int</span> oth = <span class="built_in">ksm</span>(<span class="built_in">ksm</span>(<span class="number">2</span>,n - i),m - <span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> cnt = ((tmp * oth) % mo * C[n][i]) % mo;</span><br><span class="line">		(ans += cnt) %= mo; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ans &lt; <span class="number">0</span>) ans += mo;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="b"><strong>B</strong></h3>
<p>​ Given two integer <span class="math inline">\(n\)</span> and <span
class="math inline">\(m\)</span>, among all the sequence containing n
non-negative integers less than <span
class="math inline">\(2^m\)</span>, you need to count the number of such
sequences <span class="math inline">\(A\)</span> that there exists
<strong>at least two different</strong> non-empty subsequence of <span
class="math inline">\(A\)</span> in which the bitwise AND of the
integers is <span class="math inline">\(1\)</span>.</p>
<p>​ Since the answer may be very large, output it modulo a positive
integer <span class="math inline">\(q\)</span>.</p>
<p><strong>Input</strong></p>
<p>​ The only line contains three integers <span
class="math inline">\(n,m,q\)</span>. (<span class="math inline">\(1 \le
n,m \le 5000, 1 \le q \le 10^9\)</span>)</p>
<p><strong>Output</strong></p>
<p>​ Output a line containing an integer, denoting the answer.</p>
<p><strong>Sample input 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 998244353</span><br></pre></td></tr></table></figure>
<p><strong>Sample output 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<p><strong>Sample input 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5000 5000 998244353</span><br></pre></td></tr></table></figure>
<p><strong>Sample output 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">530227736</span><br></pre></td></tr></table></figure>
<hr />
<p><strong>Solution:</strong> <a
href="https://www.bilibili.com/video/BV17VsWeUE7L/?spm_id_from=333.999.0.0&amp;vd_source=ad1b7dc4c298c14955ef2d4f1bcdb8b0">牛客2024D1TB_哔哩哔哩_bilibili</a></p>
<p><strong>Code:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> f(i,l,r) for (int i=l; i&lt;=r; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,mo,ans1,ans2;</span><br><span class="line"><span class="type">int</span> C[maxn][maxn],dp[maxn][maxn];</span><br><span class="line"><span class="type">int</span> f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">			(ans *= x) %= mo;</span><br><span class="line">		y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		(x *= x) %= mo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(i,<span class="number">1</span>,<span class="number">5000</span>)</span><br><span class="line">		C[i][i] = C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">f</span>(i,<span class="number">2</span>,<span class="number">5000</span>)</span><br><span class="line">		<span class="built_in">f</span>(j,<span class="number">1</span>,i - <span class="number">1</span>) &#123;</span><br><span class="line">			C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mo;			</span><br><span class="line">		&#125;</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">f</span>(i,<span class="number">1</span>,<span class="number">5000</span>) </span><br><span class="line">		f[i] = (f[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) % mo;</span><br><span class="line">	<span class="comment">//dp[i][j] = ksm(2^i - 1 - j, m - 1)</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">f</span>(i,<span class="number">1</span>,n) &#123;  <span class="comment">// j in [0,i]</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=i; j+=<span class="number">2</span>)</span><br><span class="line">			dp[i][j] = (dp[i - <span class="number">1</span>][((<span class="number">1</span> + j) &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>] * f[m - <span class="number">1</span>]) % mo;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;=i; j+=<span class="number">2</span>)</span><br><span class="line">			dp[i][j] = <span class="built_in">ksm</span>(f[i] - <span class="number">1</span> - j,m - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">pre</span>();</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">f</span>(i,<span class="number">0</span>,n) &#123;</span><br><span class="line">		<span class="type">int</span> v = f[i] - <span class="number">1</span>; <span class="keyword">if</span> (v &lt; <span class="number">0</span>) v += mo;</span><br><span class="line">		<span class="type">int</span> tmp = (<span class="built_in">ksm</span>(f[i], m - <span class="number">1</span>) - <span class="built_in">ksm</span>(v,m - <span class="number">1</span>)) % mo;</span><br><span class="line">		<span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) tmp += mo;</span><br><span class="line">		<span class="type">int</span> oth = <span class="built_in">ksm</span>(f[n - i],m - <span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> cnt = ((tmp * oth) % mo * C[n][i]) % mo;</span><br><span class="line">		ans += cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	ans = (<span class="built_in">ksm</span>(f[n],m) - ans) % mo;</span><br><span class="line">	<span class="keyword">if</span> (ans &lt; <span class="number">0</span>) ans += mo;</span><br><span class="line">	ans1 = ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 	freopen(&quot;in.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">// 	freopen(&quot;1.out&quot;,&quot;w&quot;,stdout); </span></span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;mo;</span><br><span class="line">	<span class="keyword">if</span> (mo == <span class="number">1</span>) &#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solve1</span>();</span><br><span class="line">	<span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="keyword">final</span> = f[n] - n - <span class="number">1</span>; <span class="keyword">final</span> %= mo; <span class="keyword">if</span> (<span class="keyword">final</span> &lt; <span class="number">0</span>) <span class="keyword">final</span> += mo;</span><br><span class="line">		cout&lt;&lt;<span class="keyword">final</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">f</span>(i,<span class="number">0</span>,n) &#123; <span class="comment">// i: the number of how many entry with the least significant bit being 1</span></span><br><span class="line">		<span class="keyword">if</span> (i &gt; m - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> p = f[i] - <span class="number">1</span>; </span><br><span class="line">		<span class="built_in">f</span>(j,<span class="number">0</span>,i) &#123;</span><br><span class="line">			<span class="comment">//dp[i][j] = ksm(2^i - 1 - j, m - 1)</span></span><br><span class="line">			<span class="type">int</span> tmp = (dp[i][j] * C[i][j]) % mo;</span><br><span class="line">			<span class="keyword">if</span> (j &amp; <span class="number">1</span>) tmp = (~tmp + <span class="number">1</span>);</span><br><span class="line">			sum += tmp;	</span><br><span class="line">		&#125; </span><br><span class="line">		sum %= mo;</span><br><span class="line"><span class="comment">//		if (sum &lt; 0) sum += mo;</span></span><br><span class="line">		<span class="type">int</span> oth = <span class="built_in">ksm</span>(f[n - i],m - <span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> loc = ((sum * oth) % mo * C[n][i]) % mo;</span><br><span class="line">		ans2 += loc;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="keyword">final</span> = (ans1 - ans2) % mo; <span class="keyword">if</span> (<span class="keyword">final</span> &lt; <span class="number">0</span>) <span class="keyword">final</span> += mo;</span><br><span class="line">	cout&lt;&lt;<span class="keyword">final</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	int sum = 0;</span></span><br><span class="line"><span class="comment">		f(j,0,i - 1) &#123;</span></span><br><span class="line"><span class="comment">			int tmp = ksm(n - j,m - 1) * C[i][j];</span></span><br><span class="line"><span class="comment">			if (j &amp; 1) tmp = -tmp; tmp %= mo;</span></span><br><span class="line"><span class="comment">			(sum += tmp) %= mo;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>2024多校</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言指针相关</title>
    <url>/2023/10/16/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88&amp;%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>1.<code>char *s[]</code> 若执行<code>s++</code>，则：</p>
<p>2.<code>char **s</code>
若执行<code>s++</code>，则：向后一个指针的大小（一般为4个字节）</p>
<p>3.<code>char (*s)[]</code>
则s是指向一行的指针，若执行<code>s++</code>，则s会指向下一行</p>
<p>4.<code>int **a</code>
若执行<code>a++</code>，则：向后一个指针的大小（一般为4个字节）</p>
<p>5.<code>int *a[]</code> 若执行<code>a++</code>，则：</p>
<p>6.<code>int (*a)[]</code>
则a是指向一行的指针，若执行<code>a++</code>，则a会指向下一行</p>
<ul>
<li>1和2如果写在函数的形参里面，那么是等价的。</li>
<li>4和5如果写在函数的形参里面，那么是等价的。</li>
<li>如果1不是写成函数的形参，那么s就是一个常量，不能更改。</li>
<li>如果2不是写成函数的形参，那么s就是一个变量，可以更改。</li>
<li>3和6都是指向一行的指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> **a = b;</span><br><span class="line"><span class="comment">//不能这样写，因为b是指向行的指针</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> **a = &amp;b[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//b[0]是常量，一般取不了</span></span><br></pre></td></tr></table></figure>
<p><strong>一般来说，二级指针是和指针数组相关联的</strong>，<code>int (*a)[]</code>
这种是和二维数组相关联的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *s[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">char</span> **s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">puts</span>(*s);</span><br><span class="line">	s++;</span><br><span class="line">	<span class="built_in">puts</span>(*s);</span><br><span class="line">	s++;</span><br><span class="line">	<span class="built_in">puts</span>(*s);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	s[<span class="number">0</span>] = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">	s[<span class="number">1</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">	s[<span class="number">2</span>] = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">	<span class="built_in">work</span>(s);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123</span><br><span class="line">abc</span><br><span class="line">ABC</span><br></pre></td></tr></table></figure>
<hr />
<p>观察这段程序，问题出在哪里？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> (*p)[])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,**p);</span><br><span class="line">	p+=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,**p);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">fun</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：没有声明所指向的一行有多少个元素，改为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> (*p)[<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,**p);</span><br><span class="line">	p+=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,**p);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">fun</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<hr />
<p>如果声明了<code>int *a = malloc(size);</code>，那么之后可以用<code>a[i]</code>表示<code>*(a + i)</code></p>
]]></content>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-lecture-6</title>
    <url>/2024/08/02/CSAPP%20lecture%206/</url>
    <content><![CDATA[<h3 id="csapp-lecture-6">CSAPP lecture 6</h3>
<h4 id="condition-code">1. Condition code</h4>
<ul>
<li><p>Four condition codes:</p>
<ul>
<li>CF: Carry Flag. Will be 1 if there is a carry out of the most
significant bit. Used to detect the overflow of the unsigned number</li>
<li>ZF: Zero Flag. Will be 1 if the most recent operation yield 0.</li>
<li>SF: Sign Flag. Will be 1 if the most recent operation yield a value
with the sign bit being 1.</li>
<li>OF: Overflow Flag. Will be 1 if the most recent operation caused an
overflow (for two's complement), either positive overflow or negative
overflow.</li>
</ul>
<blockquote>
<p>The leaq operation would not alter any of the condition code. All
other arithmetic operation would make these condition code to
change.</p>
</blockquote></li>
<li><p>For the logical operation (such as <code>xor</code>
<code>or</code> <code>add</code>), they will leave the CF and OF to be
0.</p></li>
<li><p>For the shift operation, the CF will be set to the last digit
shifted out, and the OF will be set to 0.</p></li>
<li><p>For the <code>inc</code> and <code>dec</code> operation, they
will set the OF and ZF, but they will leave the CF unchanged.</p></li>
<li><p>There are two instruction classes which can only alter the
condition codes without changing the other value.</p></li>
</ul>
<p>​</p>
<p>​ We can check the sign of a value or whether this value is 0 by
<code>test %rax %rax</code>. (Suppose this value is stored in register
<code>%rax</code>)</p>
<h3 id="access-the-condition-code">2. Access the condition code</h3>
<ul>
<li>Access the condition code: Rather than directly access the condition
code, we prefer to access the condition code indirectly, using the
following 3 methods:
<ul>
<li>We can set a single byte to 0 or 1, depending on some combination of
the condition codes.</li>
<li>We can conditionally jump to some part of the program</li>
<li>We can conditionally transfer data.</li>
</ul></li>
</ul>
<h5 id="how-to-set-a-single-byte-according-to-the-condition-code">2.1
How to set a single byte according to the condition code</h5>
<p>​ These <code>set</code> class of instruction have a single operand
<code>D</code> indicating the destination. The destination have to be a
register or a memory location. If it is a register, then it would set
the least significant byte of the register to 1 (usually this register
have to be <code>%al</code> kind rather than <code>%rax</code>
kind.)</p>
<p>​ an example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">comp:</span><br><span class="line">	cmpq	%rsi %rdi</span><br><span class="line">	setl	%al</span><br><span class="line">	movzbq	%al %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<h5 id="conditionally-jump-to-some-part-of-the-program">2.2
(Conditionally) jump to some part of the program</h5>
<p><strong>Unconditionally jump:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	movq $0, %rax</span><br><span class="line">	jmp .L1</span><br><span class="line">	movq (%rax), %rdx</span><br><span class="line">.L1:</span><br><span class="line">	popq %rdx</span><br></pre></td></tr></table></figure>
<p>The <code>jmp</code> instruction would jump to <code>.L1</code>
label</p>
<p><code>jmp</code> is the unconditional jump operation. It can jump
directly or indirectly. When it is directly, it's something like
<code>jmp .L1</code>. When it is indirectly, it is something like
<code>jmp *%rax</code> or <code>jmp *(%rax)</code>, where the label is
stored in the register <code>%rax</code> or the memory location
<code>(%rax)</code></p>
<p><strong>Conditional jump:</strong></p>
<h5 id="jump-instruction-encodings">2.3 Jump instruction encodings</h5>
<p>​ In assembly code, to specify where we want to jump to we can simply
write something like <code>.L1</code> happily. In the disassembled
machinery code <strong><em>(the assemble code translated from the
machinery code)</em></strong>, the <code>jump</code> operation would
written in the form like <code>jmp 0x1137</code>. There will be an
address operand like <code>0x1137</code> to specify which operation will
the program jump to. In this case, the jump operation would jump to
<code>0x1137</code> and do the operation in <code>0x1137</code></p>
<p>​ But in machinery code, how to specify where we want to jump to?
There are two ways to do this, first is so called
<code>PC relatives</code>. That is saying, they encode the target
address as the difference between the target address and the address of
the instruction immediately following the jump instruction.</p>
<blockquote>
<p>The difference between a and b is a - b</p>
</blockquote>
<p>​ The reason why we try to use this kind of notation is that the jump
target would remain unchanged when the whole program is shifted to
another address.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eb 03 # In this case, 0x03 is the encoded jump target. 0x03 has to be 							added by the address of the next instruction to get the 								target address. </span><br><span class="line"># &quot;eb 03&quot; is a machine code in binary. &quot;eb&quot; specifies the type of the operation and &quot;03&quot; specifies the encoded jump target</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: this <code>0x03</code> is a two's complement number, so for
example, if now it is <code>0xFF</code>, then it is actually -1, and the
actual jump target would be the address of the next instruction minus
1.</p>
</blockquote>
<p><strong><em>Question</em></strong></p>
<p>​ Sometimes we would see operation <code>jmp .L1</code> and sometimes
we would see operation <code>jmp 0x1137</code>. Which one (probably
both) is the assembly code? What's difference between these two
command?</p>
<h5 id="conditional-move">2.4 Conditional Move</h5>
<p>​ Apart from the <code>jump</code> operation, we have an operation
called conditional move.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">comp</span><span class="params">(<span class="type">long</span> x,<span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> res;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">        res = y - x; <span class="keyword">else</span></span><br><span class="line">        res = x - y;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For example, this C code might be translated into the following
assembly code:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">	movq 	%rsi, %rax</span><br><span class="line">	subq	%rdi, %rax</span><br><span class="line">	movq	%rdi, %rdx</span><br><span class="line">	subq	%rsi, %rdx</span><br><span class="line">	cmpq	%rsi, %rdi</span><br><span class="line">	cmovge	%rdx, %rax	#If the last comparison said &quot;%rdi &gt;= %rsi&quot;, then this move will 						  conditional move will apply. Otherwise nothing will happen.</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p><strong><em>Question</em></strong></p>
<p>​ Why will the conditional move operation reduce the penalty for
misprediction? It also need to decide whether to do the move
instruction, and the misprediction should affect the following pipeline
as well.</p>
<p><strong>The class of conditional move:</strong></p>
<p>​ Some property for the conditional move:</p>
<ul>
<li>The destination must be register</li>
<li>The data type can be 2,4,8 bytes long, but can't be 1 byte long</li>
<li>The instruction don't need a suffix to specify the data type. The
processor could infer the operand length from the name of the
destination register.</li>
</ul>
<blockquote>
<p>The condition move may not be valid if one expression is invalid.</p>
<p>for example</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">else</span></span><br><span class="line">    reutnr *p;</span><br></pre></td></tr></table></figure>
<p>You can not calculate <code>*p</code> beforehand as <code>p</code>
may be a null pointer, making the dereferencing invalid.</p>
</blockquote>
]]></content>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>Acwing299题解</title>
    <url>/2023/06/15/ACwing299%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="acwing-299-裁剪序列也许它能帮到你">Acwing 299
裁剪序列（也许它能帮到你）</h1>
<h3 id="题意">1.题意：</h3>
<p>给定一个长度为 <span class="math inline">\(N\)</span> <span
class="math inline">\((N \le 1e5)\)</span>的序列 <span
class="math inline">\(A\)</span>
，要求把该序列分成若干段，在满足“每段中所有数的和”不超过M的前提下，让“每段中所有数的最大值”之和最小。</p>
<p>试计算这个最小值。</p>
<h3 id="分析">2.分析</h3>
<p>朴素DP：</p>
<ul>
<li><p>状态：设<span class="math inline">\(f[i]\)</span> 表示将前 <span
class="math inline">\(i\)</span> 个数分为若干段，每段和不超过 <span
class="math inline">\(m\)</span> 时，最大值之和的最小值。</p></li>
<li><p>转移方程： <span class="math display">\[
  f[i] = min(f[j] + max(a[j + 1],a[j + 2],……a[i])) \ \ \ \ (\sum_{k = j
+ 1}^na_k \le m)
  \]</span> 其中的区间最大值和区间和分别可以用ST表和前缀和完成。</p>
<p>复杂度<span class="math inline">\(O(n^2)\)</span>.</p>
<p>接下来来考虑优化。</p></li>
</ul>
<blockquote>
<p>若<span class="math inline">\(j\)</span>可能作为<span
class="math inline">\(f[i]\)</span>的唯一最优决策，那么<span
class="math inline">\(j\)</span>必须满足下面两个条件<strong>之一</strong>：</p>
<ul>
<li><span class="math inline">\(a[j]\)</span>是<span
class="math inline">\(a[j],a[j + 1],……,a[i]\)</span>中的最大值</li>
<li><span class="math inline">\(\sum_{k = j}^i a_k &gt; m\)</span></li>
</ul>
</blockquote>
<p>证明：</p>
<p>若<span
class="math inline">\(j\)</span>对上述两个条件都不满足，那么对于决策<span
class="math inline">\(j - 1\)</span>：</p>
<p>因为<span class="math inline">\(\sum_{k = j}^i a_k \le
m\)</span>，所以决策<span class="math inline">\(j -
1\)</span>是合法的。</p>
<p>同时因为<span class="math inline">\(a[j]\)</span>不是<span
class="math inline">\(a[j],a[j + 1],……,a[i]\)</span>中的最大值，所以</p>
<p><span class="math display">\[
\max(a[j + 1],a[j + 2],……a[i]) = \max(a[j],a[j + 1],a[j + 2],……a[i])
\]</span></p>
<p>又因为<span class="math inline">\(f[i]\)</span>单调不减，所以： <span
class="math display">\[
f[j - 1] + max(a[j],a[j + 1],a[j + 2],……a[i])\le f[j] + max(a[j + 1],a[j
+ 2],……a[i])
\]</span> 即决策<span class="math inline">\(j - 1\)</span>比决策<span
class="math inline">\(j\)</span>更优或相等，所以决策<span
class="math inline">\(j\)</span>不会是唯一的最优决策。</p>
<p>对于考虑满足第二个条件的决策，我们可以预处理出<span
class="math inline">\(c[i]\)</span>，表示满足<span
class="math inline">\(\sum_{k = j}^ia_k \le m\)</span>的最小的<span
class="math inline">\(j\)</span>。然后对于<span
class="math inline">\(f[i]\)</span>，执行<code>f[i] = min(f[i],f[c[i] - 1]+max(a[c[i]],a[c[i] + 1],a[c[i] + 2],……,a[i]))</code></p>
<p>​</p>
<p>对于考虑满足第一个条件的决策，我们可以考虑用单调队列来优化DP。</p>
<p>循环变量<span
class="math inline">\(i\)</span>，循环开始先从队头剔除不合法的决策（即状态转移中的条件）</p>
<p>然后将<span
class="math inline">\(i\)</span>入队，同时维护单调队列元素<span
class="math inline">\(x\)</span>的<span
class="math inline">\(a[x]\)</span>单调不增，保证单调队列中的决策都是可能的最优决策。</p>
<p>但是这样我们还是需要循环整个单调队列枚举所有决策。</p>
<p>接下来我们来集中解决这个问题。</p>
<p>我们先建立一个used数组。</p>
<p>我们再建立一个小根堆，其中的元素为(id,x)，按x作为比较的依据。表示对于决策<span
class="math inline">\(id\)</span>，x表示<span
class="math inline">\(f[id] + max(a[id + 1],a[id +
2],……a[id])\)</span>。</p>
<p>每次向单调队列中插入一个新决策<span
class="math inline">\(j\)</span>时，同时也向堆中插入这个决策<span
class="math inline">\((j,f[j] + max(a[j + 1],a[j +
2],……,a[i]))\)</span>。当从单调队列中删除一个决策<span
class="math inline">\(j\)</span>时，令<span
class="math inline">\(used[j] =
1\)</span>。以后从堆顶取数时，需要判断<span
class="math inline">\(used[top().id]\)</span>是否为1，若是1，需要将其弹出，重新取堆顶。</p>
<p>我们能这样做的一个原因在于一旦决策<span
class="math inline">\(j\)</span>被丢弃，以后该决策就不可能再次出现在单调队列中了。</p>
<p>现在我们还需要一个问题要解决：当<span
class="math inline">\(i\)</span>变成<span class="math inline">\(i +
1\)</span>时，有可能 <span class="math display">\[
\max(a[j + 1],a[j + 2],……,a[i]) \neq \max(a[j + 1],a[j + 2],……,a[i],a[i
+ 1])
\]</span> 即对于每个<span
class="math inline">\(i\)</span>，我们都需要将堆中的元素重新更新一遍。</p>
<p>为了方便起见，我们称呼<span class="math inline">\(max(a[j + 1],a[j +
2],……,a[i])\)</span>为决策<span
class="math inline">\(j\)</span>对于<span
class="math inline">\(i\)</span>的<strong>“决策 值</strong>，简写为<span
class="math inline">\(p(j,i)\)</span>。</p>
<p>我们观察一下何时<span class="math inline">\(p(j,i) \neq p(j,i +
1)\)</span>.发现：将<span
class="math inline">\(i\)</span>入队后，在单调队列<span
class="math inline">\(\{q_1,q_2,……,q_s,i\}\)</span>中，因为<span
class="math inline">\(a[q_1] \ge a[q_2] \ge ……
a[i]\)</span>，所以对于决策<span class="math inline">\(q_1,q_2,……,q_{s -
1}\)</span>，<span class="math inline">\(p(q_1,i) = p(q_1,i +
1)\)</span>,<span class="math inline">\(p(q_2,i) = p(q_2,i +
1)\)</span>,……,<span class="math inline">\(p(q_{s - 1},i) = p(q_{s -
1},i + 1)\)</span>,只有<span
class="math inline">\(p(q_s,i)\)</span>可能不等于<span
class="math inline">\(p(q_s,i + 1)\)</span>.</p>
<p>所以<span class="math inline">\(i\)</span>入队后，我们再将决策<span
class="math inline">\((id = q_s,x = f[q_s]\)</span> + $ max(a[q_s +
1],a[q_s + 2] ，……，a[i]))<span
class="math inline">\(重新入队，作为修正。可以发现，\)</span>max(a[q_s +
1],a[q_s + 2] ，…，a[i]) = a[i]$。</p>
<p>但是，决策<span
class="math inline">\(q_s\)</span>在堆里面原来的错误的值并没有被修改。为了解决这个问题，我们可以给堆的结构体中加一个变量<span
class="math inline">\(y\)</span>表示当前决策目前的"决策值"。取出堆顶的时候，如果发现堆顶决策的”决策值“不等于堆顶决策对于<span
class="math inline">\(i\)</span>应有的决策值时，就将该决策视为无效，重新取堆顶。</p>
<h3 id="code">Code:</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>,inf = <span class="number">1e15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> id,x,y;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (node a,node b) &#123;</span><br><span class="line">		<span class="keyword">return</span> a.x + a.y &gt; b.x + b.y;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[maxn &lt;&lt; <span class="number">3</span>],t,w;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn],n,m,sum[maxn],lg[maxn],st[maxn][<span class="number">30</span>],c[maxn];</span><br><span class="line"><span class="type">int</span> f[maxn]; <span class="comment">//f[i] 表示将前 i 个数分为若干段，每段和不超过 m 时，最大值之和的最小值。 </span></span><br><span class="line"><span class="type">bool</span> used[maxn];</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node&gt; h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = lg[r - l + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(st[l][len],st[r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>][len]); 	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; m) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">		st[i][<span class="number">0</span>] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	lg[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=lg[n]; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=(n - (<span class="number">1</span> &lt;&lt; i) + <span class="number">1</span>); j++)</span><br><span class="line">			st[j][i] = <span class="built_in">max</span>(st[j][i - <span class="number">1</span>],st[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">			</span><br><span class="line">	c[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=c[i - <span class="number">1</span>]; j&lt;=n; j++)</span><br><span class="line">			<span class="keyword">if</span> (sum[i] - sum[j - <span class="number">1</span>] &lt;= m) &#123;</span><br><span class="line">				c[i] = j;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// c[i] 表示 a[j] + a[j] + ……+ a[i] &lt;= m的最小的j。</span></span><br><span class="line">	<span class="comment">// f[i] 表示将前 i 个数分为若干段，每段和不超过 m 时，最大值之和的最小值。 </span></span><br><span class="line">	t = <span class="number">1</span>,w = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		f[i] = inf;</span><br><span class="line">		f[i] = <span class="built_in">min</span>(f[i],f[c[i] - <span class="number">1</span>] + <span class="built_in">query</span>(c[i],i)); <span class="comment">//考虑条件2</span></span><br><span class="line">		<span class="keyword">while</span> (t &lt;= w &amp;&amp; sum[i] - sum[q[t]] &gt; m) &#123;</span><br><span class="line">			used[q[t]] = <span class="number">1</span>;</span><br><span class="line">			t++;</span><br><span class="line">		&#125; <span class="comment">//从队头弹出非法决策</span></span><br><span class="line">			</span><br><span class="line">		<span class="keyword">while</span> (t &lt;= w &amp;&amp; a[q[w]] &lt; a[i]) &#123;</span><br><span class="line">			used[q[w]] = <span class="number">1</span>;</span><br><span class="line">			w--;</span><br><span class="line">		&#125; <span class="comment">//从队尾弹出不必要决策</span></span><br><span class="line">		q[++w] = i;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (t &lt; w) </span><br><span class="line">			h.<span class="built_in">push</span>((node)&#123;q[w - <span class="number">1</span>],f[q[w - <span class="number">1</span>]],a[i]&#125;); <span class="comment">//修正“决策值”</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (!h.<span class="built_in">empty</span>() &amp;&amp; (used[h.<span class="built_in">top</span>().id] || h.<span class="built_in">top</span>().y &lt; <span class="built_in">query</span>(h.<span class="built_in">top</span>().id + <span class="number">1</span>,i)))</span><br><span class="line">			h.<span class="built_in">pop</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (!h.<span class="built_in">empty</span>())</span><br><span class="line">			f[i] = <span class="built_in">min</span>(f[i],h.<span class="built_in">top</span>().x + h.<span class="built_in">top</span>().y); </span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>OI题目训练</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-notes</title>
    <url>/2024/08/03/CSAPP%20notes/</url>
    <content><![CDATA[<h2 id="csapp-notes">CSAPP notes</h2>
<h3 id="lecture-2">Lecture 2</h3>
<ul>
<li><table>
<thead>
<tr>
<th>Argument X</th>
<th>X = 10100010</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>&lt;&lt; 3</strong></td>
<td><strong>X = 00010000</strong></td>
</tr>
<tr>
<td><strong>logical &gt;&gt; 2</strong></td>
<td><strong>X = 00101000</strong></td>
</tr>
<tr>
<td><strong>Arithmetic &gt;&gt; 2</strong></td>
<td><strong>X = 11101000</strong></td>
</tr>
</tbody>
</table>
<p>Logical right shift would fill the high digit with zero.</p>
<p>Arithmetic right shift would fill the high digit with the sign
digit.</p></li>
<li><p>In real world practice, when you do <strong>X &lt;&lt; Y</strong>
in the machine, most machine would actually do <strong>X &lt;&lt; (Y mod
8)</strong> <strong><em>(However, when I test it locally, this mod
operation didn't apply)</em></strong></p></li>
<li><p>The difference between <strong>&amp;&amp;</strong> and
<strong>&amp;</strong>：</p>
<ul>
<li><strong>&amp;&amp;</strong> would only return 0 or 1, while
<strong>&amp;</strong> can return all kinds of integers</li>
<li><strong>&amp;&amp;</strong> would consider any non-zero integer as
1, and consider 0 as 0. <strong>&amp;</strong> certainly don't have this
trait</li>
<li>When the outcome of an expression is known,
<strong>&amp;&amp;</strong> would not calculate the rest of the
expression. For example, if <code>int x = 0</code>, and we calculate
expression <code>a&amp;&amp;(5/a)</code>, it would not raise an
DIVIDEZERO error as the second part would not be calculated. Similarly,
if <code>p</code> is a null pointer, then <code>p&amp;&amp;*p++</code>
would not access a null pointer as the second part would be
omitted.</li>
</ul></li>
<li><p>If you shift left by a negative number, the outcome might not be
a right shift. For example, <code>1 &lt;&lt; (-2)</code> might not be
<code>1 &gt;&gt; 2</code></p></li>
<li><p>A different way to understand <strong>two's
complement</strong></p>
<p>For example, the two's complement of a number is
<code>10110001</code>, then the value of this number should be: <span
class="math display">\[
1\times (-2^7) + 0 \times 2^6 + 1 \times 2^5 + 1 \times 2^4 + 0 \times
2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0
\]</span></p>
<p>In other word, when it comes to two's complement, we consider the
weight of the highest digit to be negative. More accurately, the weight
of the highest digit should be the opposite number of its original
weight.</p></li>
<li><p>If a comparison operation involves two signed numbers, then it
would do it signed ways. If a comparison operation involves two unsigned
umbers, then it would do it unsigned ways.</p>
<p>However, if a comparison operation involves a signed number and an
unsigned number, then it would first transform the signed number into
unsigned form then compare these two unsigned numbers.</p>
<p>For example, if <code>int x = -1; unsigned int y = 0</code>, then
<code>x</code> would be greater than <code>y</code>. In other word,
<code>x &gt; y</code> would be true.</p>
<p>This rule applies to other operations, including add, minus,
etc.</p></li>
<li><p>Define <code>int x = -2147483648</code> might make the compiler
confused for obscure reason. You can do the same thing by
<code>int x = -2147483647 - 1</code></p></li>
<li><p>An example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">10</span>; i - <span class="keyword">sizeof</span>(<span class="type">char</span>) &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\&quot;,i);</span></span><br></pre></td></tr></table></figure>
<p>For this program, what you will get is just an endless loop.
Why？because <code>sizeof(char)</code> is an unsigned number, making the
whole bunch of <code>i - sizeof(char)</code> to be considered unsigned.
Thus, <code>i - sizeof(char)&gt;=0</code> always holds, making the loop
endless.</p></li>
<li><p>How to promote a smaller type of integer to a larger type of
integer?</p></li>
</ul>
<p><span class="math inline">\(\hspace{1cm}\)</span> For example, if we
have a variable <code>x</code> of type <code>int</code>, how do we cast
it to type <code>long long</code>?</p>
<p><span class="math inline">\(\hspace{1cm}\)</span> Simply by
repeatedly copying the sign digit and insert it to the left until the
number of digit reach the word size of long long.</p>
<p><span class="math inline">\(\hspace{1cm}\)</span> This is both true
when it is a two's complement number and when it is an unsigned
number.</p>
<hr />
<h3 id="lecture-3">Lecture 3</h3>
<ul>
<li><p>Addition for unsigned number (A.K.A. <code>UAdd</code>) :</p>
<p>Computer will just add the two numbers up and abandon the higher
digit if it exceeds the word size.</p>
<p>For unsigned number <code>u</code> and <code>v</code>，perform
addition between them would lead to the result of <span
class="math inline">\((u + v) \% 2^w\)</span> , with <code>w</code>
representing the word size.</p></li>
<li><p>Addition for two's complement number (A.K.A
<code>TAdd</code>):</p>
<p>Computer will do the same thing in <code>UAdd</code>: Add the two
numbers up and abandon the higher digit if it exceeds the word size.</p>
<p>For example, if we have a 4-digit two's complement number
<code>u = 1101</code> and <code>v = 0101</code>. So u is actually -3 and
v is actually 5. Thus, u + v should be 2 arithmetically. When we add the
<code>1101</code> and <code>0101</code>, we got <code>10010</code>, and
we abandon the most significant digit and we got <code>0010</code>,
which is 2 and it matches the arithmetic result.</p>
<p>Another example: <code>u = 1101, v = 1010</code>, so u is actually -3
and v is actually -6, so u + v should be -9 arithmetically. If we add
<code>1101</code> and <code>1010</code>, we got <code>10111</code>.
Abandon the highest digit we got <code>0111</code>, which is 7.</p></li>
<li><p><code>UAdd</code> and <code>TAdd</code> have identical Bit-level
behavior</p></li>
<li><p>Multiplication for unsigned number:</p>
<p>Similar to addition, computer would first calculate the product, then
abandon the higher digit exceeding the word size. Simply put, <span
class="math inline">\(u \times v\)</span> would be <span
class="math inline">\((u \times v) \% (2^w)\)</span>, with <span
class="math inline">\(w\)</span> representing the word size</p></li>
<li><p>Multiplication for two's complement number:</p>
<p>Computer would first calculate the product, then abandon the higher
digit exceeding the word size.</p>
<p>For example, if <code>u=0101</code> and <code>v = 0101</code>, then
<span class="math inline">\(u \times v = 11001\)</span>. Abandon the
highest digit we got <code>1001</code> , that would be -7.</p></li>
<li><p>A property for two's complement</p>
<p>Assume a number <code>x</code> can be represented <span
class="math inline">\((\overline{a_1 a_2 a_3 ... a_n})_2\)</span> in
two's complement. Let's denote <span
class="math inline">\((\overline{a_1 a_2 a_3 ... a_n})_2\)</span> as
<span class="math inline">\([a_1,a_2,...,a_n]\)</span>. And we could
assert that: if <span class="math inline">\(x =
[a_1,a_2,...,a_n]\)</span>, then: <span class="math display">\[
-x = [1 - a_1,1 - a_2, ... , 1 - a_n] +1
\]</span> Notice: the last "+" operation will be done in computer ways,
which means if it overflows, then the highest digit would be
omitted.</p>
<p>For example, 0 = [0,0,0,0], so -0 = [1,1,1,1] +1 = [1,0,0,0,0], then
we omit the highest number, then we could get [0,0,0,0], and the result
is correct.</p></li>
<li><p>It appears that in my computer, when you do a "&gt;&gt;"
operation then it would actually perform <strong>arithmetic
&gt;&gt;</strong></p></li>
<li><p>In a 64-bit word size machine, the address of the memory would be
8-bytes (which is also 64 bits). Thus, if we do
<code>printf("%d\n",sizeof(int*))</code>, then it would probably get
"8".</p></li>
<li><p>Terminology time:</p>
<p><strong>Word</strong> means a range of memory unit storing a specific
type of data. For example, an <code>int</code> word is comprised of 2
bytes, an <code>long long</code> word is comprised of 4 bytes.</p></li>
<li><p>So, how are the bytes within a multi-byte word ordered in
memory?</p>
<p>Two ways: <strong>Big Endian</strong>; <strong>Little
Endian</strong>;</p></li>
</ul>
<p>​ Little Endian is the major way today.</p>
<p>​ The internet still use Big Endian.</p>
<ul>
<li><p>The way to store strings:</p>
<p>Computer would just store the string from head to tail char-wise.
There's no big-endian or little-endian here.</p></li>
</ul>
<p>​ (Notes: IA32 is a little-endian machine, and Sun is a big-endian
machine)</p>
<hr />
<h3 id="lecture-4">Lecture 4</h3>
<ul>
<li><p>An example <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="number">2</span>/<span class="number">3</span>)==(<span class="number">2</span>/<span class="number">3.0</span>));</span><br></pre></td></tr></table></figure></p>
<p>In fact, this program would output 0. Because (2/3) is an integer
while (2 / 3.0) is a double number. Thus, the equation can not
hold.</p></li>
<li><p>Implicit Conversion</p>
<p>In the C language, when an operation involves multiple types of
variables, type conversions occurs to make sure that the type of
different variables match. In operations, implicit conversions take
place. Type conversions can also be called as cast.</p>
<ul>
<li>All integer type smaller than <code>int</code> (like
<code>short</code>, <code>char</code>) will be promoted to
<code>int</code></li>
<li>Low precision type will be cast to high precision
type.(<code>int</code> would be cast to <code>float</code>,
<code>float</code> would be cast to <code>double</code>)</li>
</ul></li>
<li><p>Immediate Value</p>
<p>In the C language, immediate value refers to a constant value that is
directly specified in code.</p>
<p>The immediate value is also known as a literal.</p>
<p>In the C language, the immediate value <code>3.14</code> are treated
as type <code>duoble</code> by default.</p></li>
<li><p>IEEE floating point representation</p>
<p>The IEEE float point representation represents a number in the form
<span class="math inline">\(V = (-1)^s \times M \times 2^E\)</span></p>
<p>The sign <code>s</code> determine whether this number is positive or
negative</p>
<p>The exponent <code>E</code> weights the value by a (possibly
negative) power of 2.</p>
<p>Floating-point number are represented in three fields above.</p>
<ul>
<li><p>The single sign bit in the front directly encode sign
<code>s</code></p></li>
<li><p>The <span class="math inline">\(k-bit\)</span> exponent field
<span class="math inline">\(exp = e_{k-1}e_{k - 2}...e_0\)</span>
encodes the exponent <span class="math inline">\(E\)</span></p></li>
<li><p>The <span class="math inline">\(n - bit\)</span> fraction field
<span class="math inline">\(frac = f_{n - 1}f_{n - 2}...f_0\)</span>
encodes the significand <span class="math inline">\(M\)</span></p></li>
<li><p>Normalized Case</p>
<p>When exp is not all 0 and exp is not all 1，it is the normalized
case</p>
<p>In this case, <span class="math inline">\(E = e -
bias\)</span>，where <span class="math inline">\(bias = 2^{k - 1} -
1\)</span> and <span class="math inline">\(e\)</span> is the unsigned
number having the bit representation of <span class="math inline">\(e_{k
- 1}e_{k-  2}...e_0\)</span>.</p>
<p>In this case, <span class="math inline">\(M = (1.f_{n - 1}f_{n -
2}...f_0)_2\)</span></p></li>
<li><p>Denormalized Case</p>
<p>When exp is all 0, it is the denormalized case, used to represent
floating-point number that is close to zero.</p>
<p>In this case, <span class="math inline">\(E = 1 - bias\)</span>,
where <span class="math inline">\(bias = 2^{k - 1} - 1\)</span>.</p>
<p>In this case, <span class="math inline">\(M = (0.f_{n - 1}f_{n -
2}...f_0)_2\)</span></p></li>
<li><p>Special Case A</p>
<p>When exp is all 1, and frac is all 0, this number means infinity. By
assigning s to 1 or 0, we could get positive infinity and negative
infinity.</p></li>
<li><p>Special Case B</p>
<p>When exp is all 1, and frac is not all 0, this number means
<code>NaN</code> (Not a number). Such values are returned as the result
of an operation where the result can not be given as a real number or as
infinity, as when computing <span
class="math inline">\(\sqrt{-1}\)</span> or <span
class="math inline">\(\infty - \infty\)</span> .</p></li>
</ul></li>
<li><p>Why do we have to define denormalized case?</p>
<p>In normalized case, we can not represent 0.</p>
<p>In denormalized case, we can represent 0 as well as some numbers
really close to 0.</p></li>
<li><p>Floating-point Operation</p>
<p>The IEEE standard specifies a simple of way of floating-point
operation. Viewing the two number as real numbers and just do the
operation in mathematical ways, then round the mathematical result to
yield the final result.</p>
<p>If one of the value is special (such as <code>NaN</code>,
<code>infinity</code>,<code>0</code>), the IEEE standard specify a
convention that attempt to be reasonable. To be specific,
<code>1/-0</code> is defined to yield <span
class="math inline">\(-\infty\)</span>, <span
class="math inline">\(\infty - \infty\)</span> is defined to yield
<code>NaN</code>.</p></li>
<li><p>The floating-point addition is commutative but not associative.
For example, a float <code>x = 3.14 + 1e20 - 1e20</code> would yield 0,
while a float <code>x = 3.14 + (1e20 - 1e20)</code> would yield
3.14</p></li>
<li><p>The floating-point multiplication is commutative but not
associative. For example, <code>1e20 * 1e20 * 1e-20</code> would yield
<span class="math inline">\(+\infty\)</span>, while
<code>1e20 * (1e20 * 1e-20)</code> would yield <code>1e20</code></p>
<p>The floating-point multiplication does not distribute over
addition.</p></li>
<li><p>Conversion between <code>int</code>, <code>float</code> and
<code>double</code>:</p>
<ul>
<li><code>int</code> -&gt; <code>float</code>: The number will not
overflow, but it may be rounded.</li>
<li><code>int or float</code> -&gt; <code>double</code>: The number will
not overflow and it will not be rounded. Because it has both greater
range and greater precision.</li>
<li><code>double</code> -&gt; <code>float</code>: The number might
overflow(leading to <span class="math inline">\(+\infty\)</span> or
<span class="math inline">\(-\infty\)</span>) or be rounded.</li>
<li><code>float or double</code> -&gt; <code>int</code>: The number
would be rounded toward <span class="math inline">\(0\)</span>.</li>
</ul></li>
<li><p>Infinity can be compared. It is compared in mathematical
ways.</p></li>
<li><p>For floating-point number <span
class="math inline">\(a\)</span>,<span
class="math inline">\(b\)</span>,<span
class="math inline">\(c\)</span></p>
<ul>
<li>if $ a&gt; b$, then <span class="math inline">\(a + c &gt; b +
c\)</span></li>
<li>If <span class="math inline">\(a &gt; b\)</span>, then <span
class="math inline">\(-a  &lt; -b\)</span></li>
<li>For every floating-point number <span
class="math inline">\(x\)</span>, we have <span class="math inline">\(x
\times x \ge 0\)</span></li>
</ul></li>
</ul>
<hr />
<h3 id="data-lab">Data lab</h3>
<hr />
<h3 id="lecture-5">Lecture 5</h3>
<ul>
<li><p>how to assemble a file <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S test.c</span><br></pre></td></tr></table></figure></p>
<p>Can assemble <code>test.c</code> into assemble code
<code>test.s</code></p></li>
<li><p>how to disassemble an object code file <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">objdump -d <span class="built_in">test</span> &gt; test.d</span><br></pre></td></tr></table></figure></p>
<p>Can disassemble the object code file test into assemble code file
<code>test.d</code></p></li>
<li><p>Use gdb to disassemble a function:</p>
<p>Suppose we have a program code <code>test.c</code> and we want to
disassemble the function <code>build</code> which is in this
program.</p>
<p>First we have to compile <code>test.c</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Og -o test test.c</span><br></pre></td></tr></table></figure>
<p>Then we type</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb test</span><br></pre></td></tr></table></figure>
<p>Then we would get into the gdb interface.</p>
<p>After it, we type</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">disassemble build</span><br></pre></td></tr></table></figure>
<p>and we could get the disassemble code</p></li>
<li><p>The concept of instruction set:</p>
<p>There are two kinds of prevalent instruction set,
<code>intel x86-64</code> and <code>ARM</code>. Most intel chip use
<code>x86-64</code> while mobile phone chip and apple chip use
<code>ARM</code>. The course is about <code>x86-64</code></p></li>
<li><p>The assembly code usually implement data manipulation in memory
and register. There are 16 register, and there names are as follow:</p>
<table>
<thead>
<tr>
<th>%rax</th>
<th>%r8</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>%rbx</strong></td>
<td><strong>%r9</strong></td>
</tr>
<tr>
<td><strong>%rcx</strong></td>
<td><strong>%r10</strong></td>
</tr>
<tr>
<td><strong>%rdx</strong></td>
<td><strong>%r11</strong></td>
</tr>
<tr>
<td><strong>%rsi</strong></td>
<td><strong>%r12</strong></td>
</tr>
<tr>
<td><strong>%rdi</strong></td>
<td><strong>%r13</strong></td>
</tr>
<tr>
<td><strong>%rsp</strong></td>
<td><strong>%r14</strong></td>
</tr>
<tr>
<td><strong>%rbp</strong></td>
<td><strong>%r15</strong></td>
</tr>
</tbody>
</table></li>
<li><p>the syntax <code>%rax</code> refers to the register
<code>%rax</code>, and the syntax <code>(%rax)</code> refers to the
value in register <code>%rax</code></p></li>
<li><p>A general way to designate address: <span class="math display">\[
D(R_b, R_i, S)
\]</span> <span class="math inline">\(D\)</span> is a constant, <span
class="math inline">\(R_b\)</span> and <span
class="math inline">\(R_i\)</span> are the name of two general-purpose
register, and the <span class="math inline">\(S\)</span> is the scaling
factor restricted to be 1, 2, 4, or 8. This expression specifies an
address, which would be: <span class="math display">\[
D + ([numbers \ \ in \ \ R_b] + S \times [numbers \ \ in \ \ R_i])
\]</span> For example, provided that the number stored in <span
class="math inline">\(R_b\)</span> is <code>0x100</code>, the number
stored in <span class="math inline">\(R_i\)</span> is
<code>0x200</code>, <span class="math inline">\(D = 2\)</span>, <span
class="math inline">\(S = 4\)</span>， then <span
class="math inline">\(D(R_b,R_i,S)\)</span> would designate the address
<code>2 + 0x100 + 0x200 * 4</code>, which is <code>0x902</code>.</p>
<p>(Denote: <code>D</code> is short for <em>displacement</em>, and
<code>S</code> is short for <em>scaling</em>)</p></li>
<li><p>The <code>MOV</code> grammar:</p>
<ul>
<li><p>Move an immediate value to the register:</p>
<p><code>mov $0x4, %rax</code></p>
<p>This would move the immediate value <code>0x4</code> into the
register <code>%rax</code></p>
<p>​</p></li>
<li><p>Move an immediate value to the memory:</p>
<p><code>mov $-147, (%rax)</code></p>
<p>In this case, there is an address stored in the register
<code>%rax</code> and it would move the immediate value
<code>-147</code> to that address in the memory</p></li>
<li><p>Move a value from a register to register</p>
<p><code>mov %rad, %rdx</code></p>
<p>It would copy the value stored in register <code>%rad</code> to
register <code>%rdx</code></p></li>
<li><p>Move a value from a register to memory</p>
<p><code>mov %rax, (%rdx)</code></p>
<p>It would copy the value stored in register <code>%rax</code> to the
address <code>(%rdx)</code> in the memory</p></li>
<li><p>Move a value from memory to register</p>
<p><code>mov (%rax), %rdx</code></p>
<p>vice versa</p></li>
</ul>
<p>Note: you can't move a value from memory directly to memory</p>
<p><strong>Observation:</strong></p>
<p>​ This operation simply move something into a register or the memory.
If it is a register, the second argument should be the name of the
register. If it is the memory, then the second argument should be the
address, usually designated by <code>(the name of a register)</code> or
<code>D(Rb,Ri,S)</code>.</p>
<p>​ The first argument specifies the number we want to move. The first
argument could be an immediate number, the name of a register or an
address. If it is an immediate value, then it means it would move this
literal. If it is the name of a register, then it means it would move
<strong>the number stored in the register</strong>. If it is an address,
it means it would move <strong>the number stored in this
address</strong>.</p></li>
<li><p>The <code>LEA</code> grammar</p>
<p>The general form:<code>LEA first_argument, second_argument</code></p>
<p>The first argument is an address, the second argument must be the
name of a register.</p>
<p>This operation will move the address (the first argument)
<strong>itself</strong> to the second argument (a register or an
address).</p>
<ul>
<li>The difference between <code>LEA</code> and <code>MOV</code>:
<code>LEA</code> would simply move the address <strong>itself</strong>
while <code>MOV</code> would dereference the address and move the value
stored in that address</li>
</ul></li>
</ul>
<p>​ In practice, the first argument can be literal or the name of a
register. This might violate the rule, but compiler still use this,
especially in some arithmetic operation.</p>
<p>​</p>
<blockquote>
<p>Can't understand <code>MOV</code> and <code>LEA</code>? Watch this
video: <a
href="https://www.youtube.com/watch?v=8rpXUYuV_pM&amp;t=122s">4 MOV vs
LEA (youtube.com)</a></p>
</blockquote>
<ul>
<li><p>In a function, the first parameter passed to the function will be
stored in register <code>%rdi</code>, the second parameter would be
stored in <code>%rsi</code>. The return value of a function would be
stored in register <code>%rax</code></p></li>
<li><p><code>movl</code> instruction：</p>
<p>This instruction could move a 32-bit value from one place to
another.</p>
<ul>
<li><p>From register to register:</p>
<p><code>movl %eax, %ebx</code></p>
<p>This would move the value in <code>%eax</code> to
<code>%ebx</code></p>
<p>(Note: <code>%eax</code> is the lower 32 bits of %rax, so does
<code>%ebx</code>)</p></li>
<li><p>From memory to register</p>
<p><code>movl 0x100(%rbp), %eax</code></p>
<p>This would move the 32-bit value from memory location at
<code>0x100(%rbp)</code> to register <code>%eax</code>. This would load
4 memory units and would load it upside down (because we are talking
about little-endian machine)</p>
<p>For example, here are the number stored in memory:</p>
<table>
<thead>
<tr>
<th>Memory Location</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x100</td>
<td>0x17</td>
</tr>
<tr>
<td>0x101</td>
<td>0x25</td>
</tr>
<tr>
<td>0x102</td>
<td>0x33</td>
</tr>
<tr>
<td>0x103</td>
<td>0x64</td>
</tr>
<tr>
<td>0x104</td>
<td>0x89</td>
</tr>
<tr>
<td>0x105</td>
<td>0x26</td>
</tr>
<tr>
<td>0x106</td>
<td>0x71</td>
</tr>
</tbody>
</table>
<p>If <code>%rbp = 0</code>, then after this operation,
<code>0x64332517</code> would be stored in register
<code>%eax</code>.</p></li>
<li><p>From register to memory</p>
<p>Similar, so omit it.</p></li>
<li><p>Move a literal to memory &amp; Move a literal to register</p>
<p>Similar, so omit it.</p></li>
</ul>
<blockquote>
<p>Note: After the <code>movl</code> operation, the upper-32 bits of the
destination(could be register or memory location) would be set to 0</p>
</blockquote></li>
<li><p>A general property for instructions copying and generating 1-,
2-, 4-, 8- byte values: When the destination is a register, those that
generates 1-,2- byte values leaves the remaining upper bytes unchanged,
while those that generate 4- byte values will set the upper 4 byte to
0.</p></li>
<li><p>The program counter(commonly called <code>%rip</code>) indicates
the address in memory of the next instruction to be executed.</p></li>
<li><p>The regular <code>movq</code> operation can only have immediate
source operand that can be represented in 32-bit two's complement
(Simply put, the immediate source operand must be in the range of <span
class="math inline">\([-2147483648, 2147483647])\)</span>. Then the
compiler would do sign extension to the 32-bit two's complement to make
it 64-bit, then carry out the move.</p>
<blockquote>
<p>What is sign extension?</p>
<p>​ Given a number represented in short-word-length two's complement, we
want to represent this number in a long-word-length two's complement
without changing its arithmetic value. This transformation is called
sign extension.</p>
<p>​ We can finish this task by replicating the sign digit. Whether the
number is positive or not, you will find by doing the replication the
value remain unchanged.</p>
<p>​ For example, <code>0x0011</code> after sign extension becomes
<code>0x000011</code>, the value remains unchanged. (before: 3; after:
3)</p>
<p>​ Another example: <code>0x1100</code> after sign extension becomes
<code>0x111100</code>， and the value remains unchanged (before: -4;
after: -32+16+8+4 = -4;)</p>
</blockquote></li>
<li><p>As mentioned above, the regular <code>movq</code> instruction has
limitation on literal, that's why the instruction<code>movabsq</code>
comes into life. It can move arbitrary 64-bit two's complement literal,
and the destination must be a register.</p></li>
<li><p>When copying from a smaller source to a larger destination (for
example, from a 32-bit to 64-bit), the x86-64 ISA provides two
instructions: <code>movz</code> and <code>movs</code>.</p>
<p><code>movz</code> would set the remaining higher bits to 0, while
<code>movs</code> would fill the remaining higher bits by replicating
the most significant bits of the source operand.</p>
<p>Here are some example:</p></li>
</ul>
<p>​ The operation <code>cltq</code> has the same effect of the operation
<code>movslq</code>, but it has more compact encoding.</p>
<blockquote>
<p><code>cltq</code> is short for
<code>convert l(double word) to q(quad word)</code></p>
</blockquote>
<ul>
<li><p>The unary operation:</p>
<p>It has a single operand serving as both resource and destination. For
example, we could have:</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">incq(%rax) # to increment register %rax by 1</span><br><span class="line">decq(%rax) # to decrement register %rax by </span><br></pre></td></tr></table></figure>
<ul>
<li>The arithmetic binary operation:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addq %rcx, %rax   # to increment register %rax by the value stored in %rcx</span><br><span class="line">subq %rcx, %rax   # to decrement register %rax by the value stored in %rax</span><br><span class="line">mulq %rcx, %rax   # rax &lt;---- (rax * rcx)   (value stored in rax and rcx are considered to be unsigned)</span><br><span class="line">imulq $16, (%rax,%rdx,8) # to multiply the address %rax + 8 * %rdx by a factor of 16 (value involved are considered to be two&#x27;s complement)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>For these binary operations, there are two observations:</p>
<ul>
<li>The source would be the first argument, and the destination would be
the second argument.</li>
<li>The first operand could be an immediate number, a register or a
memory location. The second operand could be an register or a memory
location. However, the first operand and the second operand could not
both be memory location.</li>
</ul>
</blockquote>
<ul>
<li><p>Shift operation:</p>
<p>The operation involves two operand, the first operand specifies the
shift amount, and the second value designates the value we want to
shift. Shift amount usually is a immediate number, but it can also be
the value stored in single-byte register <code>%cl</code>.</p>
<p>A shift operation on the data type that are <code>w</code> bits long
would use the lower <code>m</code> bits of the register
<code>%cl</code>, where <span class="math inline">\(2^m = w\)</span>.
For example, if the register <code>%cl</code> stores the hexadecimal
value of <code>$0XFF</code>, then <code>SALB</code> would shift by 7
digits, <code>SALW</code> would shift by 15 digits, <code>SALL</code>
would shift by 31 digits, and <code>SALQ</code> would shift by 63
digits.</p>
<ul>
<li><p>Left shift:</p>
<p>Comprises two instructions: <code>SAL</code> and <code>SHL</code>.
These instructions have same effect</p></li>
<li><p>Right shift:</p>
<p>Comprises two instructions: <code>SAR</code> and <code>SHR</code>.
The former is the arithmetic right shift, and the latter is the logical
right shift.</p></li>
</ul></li>
<li><p>Single Operand Multiplication:</p>
<p>​ This types comprise two operations: <code>imulq S</code> and
<code>mulq S</code>. The former one is for two's complement, and the
latter one is for unsigned. Apart from this difference, the rest are the
same, so we would only talk about <code>imulq S</code>.</p>
<p>​ The operation <code>imulq S</code> would calculate the value <span
class="math inline">\(S \times M[\%rax]\)</span> keep the all 128-bit
without truncate. Then it would store the higher 64 bits to register
<code>%rdx</code> and store the lower 64 bits to register
<code>%rax</code>.</p>
<p>​</p></li>
<li><p><code>cqto</code> operation:</p>
<p>This would convert a 64-bit value to 128-bit value. Specifically, it
would sign extend <code>%rax</code> to make it to be a 128-bit value,
and then store the upper 64 bit in <code>%rdx</code> and store the
lower-64 bit in <code>%rax</code></p></li>
<li><p><code>divide</code> operation:</p>
<p>There are divide operation: <code>idivq</code> and <code>divq</code>.
Similarly, former one is for two's complement, and the latter one is for
unsigned. Let's just talk about <code>idivq</code> since
<code>divq</code> is the same case.</p>
<p><strong>Syntax for <code>idivq</code>: </strong>
<code>idivq S</code></p>
<ul>
<li>case 1: If the bits of <code>$rdx</code> are all set to the sign bit
of <code>$rax</code> <em>(for operation <code>divq S</code>, we should
look at whether the bits of <code>$rdx</code> are all set to zero)</em>,
then we would consider that the dividend is a 64-bit value stored in
<code>$rax</code>.</li>
<li>case 2: If the bits of <code>$rdx</code> are not all set to the sign
bit of <code>$rax</code> <em>(for operation <code>divq S</code>, we
should look at whether the bits of <code>$rdx</code> are all set to
zero)</em>, then we would consider that the dividend is a 128-bit value,
with higher 64 bits stored in <code>$rdx</code> and lower 64 bits stored
in <code>$rax</code></li>
</ul>
<p>Anyway, after specifying the dividend, then the machine would do the
division, and yield a quotient and a remainder.</p>
<p>The quotient would be stored in <code>$rax</code> and the remainder
would be stored in <code>$rdx</code>.</p></li>
</ul>
]]></content>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>exgcd&amp;二元一次丢番图方程</title>
    <url>/2023/06/16/exgcd%E4%B8%8E%E4%BA%8C%E5%85%83%E4%B8%80%E6%AC%A1%E4%B8%A2%E7%95%AA%E5%9B%BE%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="exgcd二元一次丢番图方程">exgcd,二元一次丢番图方程</h1>
<h3 id="定理">1.定理</h3>
<p>对于任意<strong>整数</strong><span
class="math inline">\(a,b\)</span>，存在一对<strong>整数</strong><span
class="math inline">\(x,y\)</span>,满足<span class="math inline">\(ax +
by = gcd(a,b)\)</span>.</p>
<h3 id="证明">2.证明</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">   	<span class="keyword">return</span> <span class="built_in">gcd</span>(b,a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是辗转相除法求gcd的代码。</p>
<p>我们可以发现当<span class="math inline">\(b =
0\)</span>时，有一组<span class="math inline">\(x = 1,y =
0\)</span>，使得<span class="math inline">\(ax + by = a \times 1 + b
\times 0 = gcd(a,b) = a\)</span>。</p>
<p>对于任意一组<span
class="math inline">\(a,b\)</span>，假设存在一对整数<span
class="math inline">\(x,y\)</span>使得<span class="math inline">\(bx +
(a \% b)y = gcd(b,a \% b) = gcd(a,b)\)</span>，对它变形： <span
class="math display">\[
bx + (a \% b)y = gcd(b,a \% b) = gcd(a,b)\\bx + (a  - b \times \lfloor a
/ b \rfloor)y = gcd(a,b)\\ya + (x - y \times \lfloor a / b \rfloor)b =
gcd(a,b)
\]</span> 所以我们有了一对<span class="math inline">\(x&#39; = y,y&#39;
= x - y * \lfloor a / b \rfloor\)</span>使得<span
class="math inline">\(ax&#39; + by&#39; = gcd(a,b)\)</span>。</p>
<h3 id="代码">3.代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a,b,x,y,gcd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">		x = <span class="number">1</span>,y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="type">int</span> d = <span class="built_in">exgcd</span>(b,a % b,x,y);</span><br><span class="line">	<span class="type">int</span> z = x;</span><br><span class="line">	x = y,y = z - (a / b) * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);	</span><br><span class="line">	gcd = <span class="built_in">exgcd</span>(a,b,x,y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x,y);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求通解">4.求通解</h3>
<p>上文中我们求出了一对<span
class="math inline">\(x_0,y_0\)</span>满足<span
class="math inline">\(ax_0 + by_0 = gcd(a,b)\)</span>,现在来求通解。</p>
<p>取一组解<span
class="math inline">\((x_1,y_1)\)</span>，再任取一组解<span
class="math inline">\((x_2,y_2)\)</span>，有： <span
class="math display">\[
ax_1 + by_1 = ax_2 + by_2 = gcd(a,b)\\a(x_1 - x_2) = b(y_2 -
y_1)\\两边同时除以gcd(a,b),设a / gcd(a,b) = a&#39;,b / gcd (a,b) =
b&#39;\\a&#39;(x_1 - x_2) = b&#39;(y_2 - y_1)\\此时gcd(a&#39;,b&#39;) =
1\\所以x_1 - x_2 = kb&#39;,y_2 - y_1 = ka&#39;
\]</span></p>
<h3 id="另外一个定理">5.另外一个定理</h3>
<p>关于<strong>整数</strong><span
class="math inline">\(x,y\)</span>的方程<span class="math inline">\(ax +
by = c\)</span>有解的充要条件是<span
class="math inline">\(gcd(a,b)|c\)</span>。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb过程中的一些碎碎念</title>
    <url>/2024/11/03/gdb/</url>
    <content><![CDATA[<h3 id="gdb">gdb</h3>
<ul>
<li><p><code>$esp</code>表示寄存器<code>%esp</code></p></li>
<li><p>可以在特定机器指令的地址上打断点，例如</p>
<p><code>b *0xff3ef23f</code></p>
<p>也可以这样：</p>
<p><code>b *phase_1 + 22</code></p></li>
<li><p>寄存器<code>%pc</code>和<code>%eip</code>中存放的值貌似都是将要执行的下一条指令所在地址</p>
<blockquote>
<p><code>x/1i $pc</code>可以显示将要执行的下一条指令</p>
</blockquote></li>
<li><p>call命令会先把寄存器<code>%ip</code>压栈，然后把<code>%ip</code>赋值为调用的函数开头命令的地址</p></li>
<li><p><code>ret</code>命令相当于就是pop %ip</p></li>
</ul>
]]></content>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>OI题单</title>
    <url>/2023/06/18/OI%E9%A2%98%E5%8D%95/</url>
    <content><![CDATA[<p>p6186</p>
<p>p6185</p>
]]></content>
      <tags>
        <tag>OI题目训练</tag>
      </tags>
  </entry>
  <entry>
    <title>P6175题解</title>
    <url>/2023/06/19/P6175%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1
id="p6175数学化语言表述较严谨且易理解">P6175（数学化语言表述，较严谨且易理解）</h1>
<p>考虑一个环：<span class="math inline">\(a_1- &gt;a_2 -&gt;a_3 -&gt;……
-&gt;a_n -&gt; a_1\)</span> <span class="math inline">\((n \ge
3)\)</span>，设<span class="math inline">\(max(a_i)(1 \le i \le n) =
a_k\)</span>，设<span
class="math inline">\(a_k\)</span>在环中相邻的两个点分别是<span
class="math inline">\(a_v\)</span>和<span
class="math inline">\(a_w\)</span>。</p>
<p>对于任意的几个环，如果它们的<span
class="math inline">\(a_k,a_v,a_w\)</span>都分别相等，我们就把这几个环都放入一个集合，并设这个集合为
<span class="math inline">\(S(a_k,a_v,a_w)\)</span>。</p>
<p><strong>可以发现，任意一个环都属于一个集合。</strong></p>
<p>令<span class="math inline">\(d(x,y)\)</span>表示<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>之间直接距离（不经过其他点）。令<span
class="math inline">\(f(x,y,k)\)</span>表示x和y之间经过若干个编号<span
class="math inline">\(&lt;k\)</span>的点得到的最短距离。</p>
<p>则易证，对于任意一个集合（设这个集合为<span
class="math inline">\(S(a_k,a_v,a_w)\)</span>)，该集合中的最小环的长度为<span
class="math inline">\(d(a_v,a_k) + d(a_k,a_w) +
f(a_v,a_w,a_k)\)</span>。</p>
<p><strong>因为任意一个环都属于一个集合</strong>，所以我们只要枚举所有的集合，将该集合中最小环的长度作为可能的答案进行比较，即可得到最终答案。</p>
<p>现在还有一个问题，那就是如何求出<span
class="math inline">\(f(a_v,a_w,a_k)\)</span>。</p>
<p>我们可以发现<span
class="math inline">\(floyd\)</span>算法的外循环<span
class="math inline">\(k\)</span>枚举到<span
class="math inline">\(a_k\)</span>时，<span
class="math inline">\(a_v,a_w\)</span>之间的最短路径即为所求。</p>
<p>综上，时间复杂度<span class="math inline">\(O(n^3)\)</span>.</p>
<h3 id="code">Code:</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">105</span>,maxm = <span class="number">1e4</span> + <span class="number">5</span>,inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,vi,vj,vk,minn;</span><br><span class="line"><span class="type">int</span> f[maxn][maxn],v[maxn][maxn],a[maxn][maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v[x][y] == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> tmp = v[x][y];</span><br><span class="line">	<span class="built_in">work</span>(x,tmp);</span><br><span class="line">	path.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">	<span class="built_in">work</span>(tmp,y);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">memset</span>(a,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		f[i][i] = a[i][i] = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x,y,z;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		<span class="keyword">if</span> (x &gt; n || y &gt; n)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		a[x][y] = <span class="built_in">min</span>(a[x][y],z);</span><br><span class="line">		a[y][x] = <span class="built_in">min</span>(a[y][x],z);</span><br><span class="line">		f[x][y] = <span class="built_in">min</span>(f[x][y],z);</span><br><span class="line">		f[y][x] = <span class="built_in">min</span>(f[y][x],z);</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	minn = inf;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>; k&lt;=n; k++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;k; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=i + <span class="number">1</span>; j&lt;k; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)a[i][k] + a[k][j] + f[i][j] &lt; (<span class="type">long</span> <span class="type">long</span>)minn) &#123;</span><br><span class="line">					minn = a[i][k] + a[k][j] + f[i][j];</span><br><span class="line">					path.<span class="built_in">clear</span>();</span><br><span class="line">					path.<span class="built_in">push_back</span>(i);</span><br><span class="line">					path.<span class="built_in">push_back</span>(k);</span><br><span class="line">					path.<span class="built_in">push_back</span>(j);</span><br><span class="line">					<span class="built_in">work</span>(j,i);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i == j || j == k || i == k)</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">					</span><br><span class="line">				<span class="keyword">if</span> (f[i][j] &gt; f[i][k] + f[k][j]) &#123;</span><br><span class="line">					f[i][j] = f[i][k] + f[k][j];</span><br><span class="line">					v[i][j] = k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">			</span><br><span class="line">	<span class="keyword">if</span> (minn == inf) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;No solution.&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;path.<span class="built_in">size</span>(); i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,path[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>OI题目训练</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记</title>
    <url>/2023/10/20/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="git本地基本操作">1. Git本地基本操作</h3>
<h5 id="一些英语翻译">0. 一些英语翻译</h5>
<ul>
<li>stage : 暂存区</li>
<li>index: 暂存区</li>
<li>working tree: 当前HEAD指向的版本</li>
<li>working directory: 工作区</li>
</ul>
<h5 id="创建本地仓库">1.创建本地仓库</h5>
<p>​ 随便新建一个文件夹，然后执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<p>​
于是这个文件夹就变成了一个本地仓库（会出现一个叫做<code>.git</code>的隐藏文件夹）</p>
<h5 id="一些术语">2. 一些术语</h5>
<ul>
<li>工作区：就是你在电脑中能看到的目录（即那个文件夹）</li>
<li>暂存区：简单理解的话，就是文件被<code>add</code>之后就会被复制一份并且存储在暂存区</li>
<li>github本地仓库：简单理解的话，就是<code>commit</code>之后文件去的地方</li>
<li>版本库：包含了暂存区和本地仓库</li>
</ul>
<h5 id="四个状态一些操作">3. 四个状态，一些操作</h5>
<ul>
<li>四个状态：<code>untracked</code>，<code>unmodified</code>，<code>modified</code>，<code>staged</code></li>
</ul>
<hr />
<ul>
<li>在工作区中新建一个文件之后，输入<code>git status</code>，会发现这个文件是<code>untracked</code>状态</li>
<li>当我们<code>add</code>了这个文件之后，这个文件的状态变为<code>staged</code>，进入了暂存区</li>
<li>然后我们<code>commit</code>这个文件，完成<code>commit</code>之后这个文件库中的文件和本地文件又变为一致，此时这个文件状态变为<code>unmodified</code>。</li>
</ul>
<hr />
<ul>
<li>当我们在<code>add</code>完文件之后再对这个文件进行修改，此时这个文件会变成<code>modified</code>状态，并且使用<code>git status</code>命令时会提示我们这个文件被修改了。此时我们可以使用<code>git checkout -- 文件名</code>操作将这个文件回溯为暂存区中的版本。</li>
<li>当我们<code>add</code>并且<code>commit</code>完文件之后再对这个文件进行修改，那么这个文件会变成<code>modified</code>状态。此时我们依旧可以使用<code>git checkout -- 文件名</code>操作将这个文件回溯为本地库中的版本。</li>
<li>如果本地库中的文件版本与工作区的不同，即使我们<code>add</code>了工作区中的文件，这个文件的状态依旧是<code>modified</code>。此时如果我们对这个文件进行<code>checkout</code>，这个文件的内容不会有任何改变。</li>
<li>如果工作区的文件，暂存区的文件和本地库中的文件版本各不相同，那么<code>git checkout -- 文件名</code>会把工作区的文件回溯为暂存区中的版本。</li>
</ul>
<blockquote>
<p>一言以蔽之，在这个文件<code>add</code>或<code>commit</code>之后再做修改，这个文件的状态就会变成<code>modified</code>。然后如果对这个文件执行<code>git checkout --</code>，就会把这个文件回溯到最近一次<code>git commit</code>
或<code>git add</code>时候的状态。</p>
</blockquote>
<h5 id="git-log命令">4. git log命令</h5>
<p>​
输入<code>git log</code>之后进入一个页面，可以按回车不停往下翻；可以按下键盘上的Q键退出日志；</p>
<p>​
<code>git log</code>中最重要的部分在于它会显示每个提交的<code>hash</code>值。</p>
<h5 id="如何查看git中的文件内容和文件目录">5.
如何查看Git中的文件内容和文件目录？</h5>
<ul>
<li><p>如何查看工作区的文件内容&amp;文件目录? 用文件资源管理器 或
分别用<code>ls</code>和<code>cat</code>命令</p></li>
<li><p>如何查看本地仓库中的文件目录？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git ls-tree HEAD</span><br></pre></td></tr></table></figure></li>
<li><p>如何查看本地仓库中的某个文件内容？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git show &lt;commit&gt;:&lt;file&gt;   # &lt;commit&gt;是提交的hash值或分支名,&lt;file&gt;是文件名</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git show HEAD:&lt;file&gt;      # 直接查看当前分支中某个文件的内容</span><br></pre></td></tr></table></figure></li>
<li><p>如何查看暂存区中的文件目录？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git ls-files</span><br></pre></td></tr></table></figure></li>
<li><p>如何查看暂存区中的文件内容？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git show :&lt;file&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="git的撤销与回退">6. Git的撤销与回退</h5>
<p><code>git reset</code>实现版本回退：</p>
<ul>
<li>版本回退可以用<code>git reset</code>命令。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD^    		# 撤销到上一个版本</span><br><span class="line">$ git reset HEAD^^          # 撤销到上两个版本</span><br><span class="line">$ git reset HEAD~100		# 撤销到上100个版本</span><br><span class="line">$ git reset &lt;commit hash&gt;   # 撤销至某一个提交（commit hash是git log中的那串16进制数字，不需要全部输完，只需要输前几个数字就可以了）</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>git reset</code>可以带一些参数，一般有三种版本：</p>
<ul>
<li><code>mixed</code>，即默认版本，最常用，执行之后移动HEAD指针，同时回溯暂存区，但不动工作区</li>
<li><code>soft</code>，使用方法举例：<code>git reset --soft HEAD^</code>，执行之后移动HEAD指针，不动暂存区和工作区。</li>
<li><code>hard</code>，使用方法举例：<code>git reset --hard HEAD^</code>，执行之后即移动HEAD指针，又动暂存区，还动工作区</li>
</ul></li>
<li><p><code>git reset</code>之后发现<code>reset</code>错了，想回到<code>reset</code>之前的较新的版本，怎么办？</p>
<p>没事，只要找到较新的那个版本的<code>commit hash</code>，然后还是用<code>git reset &lt;commit hash&gt;</code>就可以了（这里的<code>&lt;commit hash&gt;</code>是那个较新版本的<code>commit hash</code>。</p></li>
<li><p><code>git reset</code>之后发现<code>reset</code>错了，而且还手滑关掉了命令行窗口，重新打开之后输入<code>git log</code>发现找不到那个较新版本的<code>commit hash</code>，怎么办？</p>
<p>没事，输入<code>git reflog</code>就可以看到之前提交的<code>commit hash</code>了。</p></li>
</ul>
<hr />
<p><code>git reset</code>也可以实现把已经添加到暂存区的对于某个文件的修改撤销掉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD &lt;file_name&gt;</span><br></pre></td></tr></table></figure>
<h5 id="文件的删除与恢复">7. 文件的删除与恢复</h5>
<ul>
<li><p>删除工作区的文件：<code>rm &lt;filename&gt;</code></p></li>
<li><p>删除完工作区的文件之后如果这个文件之前被<code>add</code>或者<code>commit</code>过，那么可以</p>
<p><code>git checkout -- &lt;filename&gt;</code>来恢复。</p></li>
</ul>
<hr />
<ul>
<li><p>先执行<code>rm &lt;filename&gt;</code>，再执行<code>git rm &lt;filename&gt;</code>，那么执行完之后这个文件在工作区和暂存区中都被删掉了</p></li>
<li><p>这个时候可以：先<code>git reset HEAD &lt;filename&gt;</code>将文件从本地仓库恢复到暂存区，然后再</p>
<p><code>git checkout -- &lt;filename&gt;</code>将文件从暂存区恢复到工作区</p></li>
</ul>
<hr />
<ul>
<li>如果直接执行<code>git rm &lt;filename&gt;</code>，然后<code>git commit -m "message"</code>，那么文件会在工作区中保留，然后再暂存区和本地仓库中都消失。</li>
</ul>
<h3 id="git远程库">2. Git远程库</h3>
<h5 id="建立ssh连接">1.建立SSH连接</h5>
<p>​ 这一步是要让本地PC与远程github建立SSH连接，具体方法为：</p>
<ul>
<li><p>打开<code>powershell</code>管理员模式，输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>注意：这里的email地址就写注册github时候用的就可以</p></li>
<li><p>在C盘用户主目录下找到<code>.ssh</code>文件夹，进入，打开<code>id_rsa.pub</code>，复制其中的内容</p></li>
<li><p>登录github打开“Account settings”，“SSH Keys”页面：</p></li>
</ul>
<p>然后，点“Add SSH
Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p>
<ul>
<li>点“Add Key”，你就应该看到已经添加的Key：</li>
</ul>
<h5 id="连接远程仓库">2. 连接远程仓库</h5>
<p>在本地仓库中<code>git bash here</code>，然后在<code>git</code>中输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add origin &lt;ssh&gt;</span><br></pre></td></tr></table></figure>
<p>这里的<code>&lt;ssh&gt;</code>是github上的仓库中的<code>ssh</code>端口地址</p>
<p>然后这里的<code>origin</code>是我们给远程库设置的名字</p>
<h5 id="将本地库的内容推送到远程仓库">3.
将本地库的内容推送到远程仓库</h5>
<ul>
<li>第一次推送的时候用这个命令：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<p>​
注：<code>git push</code>命令实际上是把当前分支<code>master</code>推送到远程</p>
<p>​
由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<ul>
<li>之后推送的时候就直接：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>​ 可以把本地<code>master</code>分支的最新修改推送至GitHub</p>
<h5 id="断开本地库和远程库之间的连接">4.
断开本地库和远程库之间的连接</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote rm origin</span><br></pre></td></tr></table></figure>
<p>用这个命令可以断开本地库和远程库之间的连接</p>
<h3 id="在vscode中使用git">3.在Vscode中使用Git</h3>
<h5 id="可能会遇到的第一个问题">1.可能会遇到的第一个问题</h5>
<p>​
当你打开vscode的<code>source control</code>模块时，vscode可能会认为你还没有安装git，并建议你安装git。可是你明明已经安装过了git，于是你觉得很奇怪。这里的原因在于你还没有更改vscode的路径。具体方法如下：</p>
<ul>
<li>打开vscode，按下<code>ctrl</code> +
<code>,</code>，在<code>settings</code>中打开搜索栏，搜索<code>git.path</code></li>
<li>点击<code>Edit in settings.json</code>文件，进入这个<code>json</code>文件</li>
<li>复制你的<code>git.exe</code>的路径，它应该长成<code>D:\application\Git\bin\git.exe</code>这样。把这个路径复制到那个<code>json</code>文件"git.path"后面</li>
<li>把你复制的路径中的<code>\</code>全部改成<code>\\</code>，不然会报错</li>
<li>最终应该长成这样：<code>"git.path": "D:\\application\\Git\\bin\\git.exe"</code>（你的路径肯定跟我不一样）</li>
<li>重启vscode</li>
</ul>
]]></content>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>ICS Notes</title>
    <url>/2024/11/25/ICS_Notes/</url>
    <content><![CDATA[<h3 id="ics-notes">ICS Notes</h3>
<ul>
<li>Carry Flag将两个操作数视作无符号数，无符号数加减溢出的时候Carry
Flag会被置为1。在实际执行的加法中，如果两个操作数的符号位相等，但不等于结果的符号位，CF会被置为1，反之为0.
在减法中，如果不够减，那么CF被置为1.</li>
</ul>
<blockquote>
<p><strong>CF (bit 0) Carry flag</strong> — Set if an arithmetic
operation generates a carry or a borrow out of the most significant bit
of the result; cleared otherwise.</p>
</blockquote>
<ul>
<li>Over
Flag将两个操作数视为有符号数。加法时，若CF=1表示加法有进位。减法时，若CF=1表示不够减。</li>
</ul>
<hr />
<ul>
<li><strong>SHL</strong>
逻辑左移，每左移一次，把最高位移到CF里，并在低位补0</li>
<li><strong>SHR</strong>
逻辑右移，每右移一次，把最低位移到CF里，并在高位补0</li>
<li><strong>SAL</strong>
算术左移，和<strong>SHL</strong>一样，只不过若移位前后sign
bit发生变化，那么OF会被置为1</li>
<li><strong>SAR</strong>
算术右移，每右移一次，把最低位移到CF里，并在高位补符号位</li>
<li><strong>ROL</strong>
循环左移，每左移一次，把最高位放到最低位，同时把最高位放到CF里</li>
<li><strong>ROR</strong>
循环右移，每右移一次，把最低位放到最高位，同时把最低位放到CF里</li>
<li><strong>RCL</strong>
把CF当成最高位加到原来的数左边，一起循环左移。</li>
<li><strong>RCR</strong>
把CF当成最低位加到原来的数右边，一起循环右移。</li>
</ul>
<hr />
<ul>
<li><p>JCXZ/JECXZ： jump if CX/ECX is 0</p></li>
<li><p>MUL</p>
<ul>
<li>单操作数 例如MUL A 意思是DX:AX = （AX * A)</li>
<li>双操作数 例如MUL S, D 意思是 D *= S</li>
<li>三操作数 例如MUL n,S,D 意思是 D = S * n, 这里D必须是寄存器</li>
</ul></li>
<li><p>IMUL: 与MUL同理</p></li>
<li><p>机器码里面的操作数如果是立即数存储方法也是小端序的，例如e8 6e ff
ff ff实际上的操作数是ff ff ff 6e</p></li>
</ul>
<hr />
<p>编译器方面的优化方式：</p>
<ol type="1">
<li>提高cache的命中率，例如把二位数组求和改成行优先</li>
<li>提高流水线的命中率，例如①把循环拆开，②采用cmov指令</li>
<li>提高单条指令的运行速度，例如把lea 0(%eax,%eax,3) %eax 改为 SAL
$2,%eax</li>
<li>使用串指令，例如在把一个数组的全部赋为0的任务中，使用memset这一封装了串指令的命令</li>
<li>使用多线程，例如在把一个数组的全部赋为0的任务中，开多个线程分别对数组的各个部分赋0</li>
<li>使用SIMD：一条指令成组操作，节约了时间</li>
<li>变量与寄存器绑定</li>
</ol>
<p>C语言方面的优化方式：</p>
<ol type="1">
<li><p>把*2改为&lt;&lt; 1，提高单调指令的效率</p></li>
<li><p>循环展开，提高流水线效率</p></li>
<li><p>二位数组行优先访问，提高cache命中率</p></li>
<li><p>使用memset等封装了串指令的命令</p></li>
<li><p>register int i</p></li>
<li><p>if （A &amp;&amp; B） 如果A满足概率90%, B 10%，那么写成if (B
&amp;&amp; A)</p></li>
<li><p>把递归改为迭代</p></li>
<li><p>用封装了SIMD的代码</p></li>
<li><p>多线程</p></li>
<li><p>减少重复计算</p></li>
</ol>
<hr />
<p>​</p>
<p>异常：CPU内部产生的错误； 中断：由外部设备产生的“外部事件”</p>
<hr />
<p>Question:</p>
<ul>
<li><p>rela.data节具体是怎么存储信息的？之前在实验四用readelf看的时候没有看到过rela.data节</p>
<blockquote>
<p>存储信息方式同rela.text;</p>
</blockquote></li>
<li><p>软中断（int命令）是异常还是中断？</p>
<blockquote>
<p>是异常</p>
</blockquote></li>
<li><p>栈帧栈顶地址是什么意思？是存返回地址的那个地方是栈顶吗？</p>
<blockquote>
<p>答：不是，是%esp的地址。栈帧的范围是从%ebp到%esp之间（闭区间）</p>
</blockquote></li>
<li><p>我想要让代码跳到0x4011d6处执行，对应的汇编代码不能直接写<code>jmp 0x4011d6</code>，而是得写成</p>
<blockquote>
<p>考试时可以这样写</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov $0x4011d6,%r10</span><br><span class="line">jmp *%r10</span><br></pre></td></tr></table></figure>
<p>这是为什么？</p>
<p>另外，如果我新建一个.s文件然后在里面写<code>jmp 0x4011d6</code>然后汇编，然后再反汇编，得到的反汇编结果是<code>jmp 0x05</code>,这是为什么？</p></li>
<li><p>一般来说，用switch效率是比用很多if要高吗？</p>
<blockquote>
<p>不一定，按习题来</p>
</blockquote></li>
<li><p>extern定义的变量名会不会出现在符号表里面（因为如果不用就不会）？这种变量是不是没有强弱符号的概念？</p></li>
<li><p>在同一个.o文件下，要么全是R_386_32重定位方式，要么全部都是R_386_PC32重定位方式？
看起来不是：（</p></li>
<li><p><strong>栈顶是低地址</strong></p></li>
<li><p><code>b8</code> mov literal, <code>a1</code> mov
直接寻址</p></li>
<li><p>外部变量不会在<code>.data</code>,<code>.bss</code>,<code>.text</code>节中</p></li>
</ul>
<p>假设LP是一个标号，那么JMP LP等价的语句是：</p>
<p><strong>LEA</strong> LP, %EAX</p>
<p>JMP *%EAX</p>
<p>字符之间的比较最好用ja,jb</p>
<p>.data 段里面定义的变量使用的时候可以替换为它的地址。</p>
<p>所有的符号（包括外部符号）只要被引用了就要重定位</p>
<p>如果<span
class="math inline">\(x\)</span>在C语言中是一个无符号数，那么<code>x &gt;&gt;= 1</code>翻译成汇编语言就会时shr</p>
<p>如果<span
class="math inline">\(x\)</span>在C语言中是一个有符号数，那么<code>x &gt;&gt;= 1</code>翻译成汇编语言就会时sar</p>
<p>基址加变址寻址：A(B,C,D)中B和C都必须要是寄存器</p>
<p>没直接问寻址方式就详细答，不放心全都写上</p>
<p><strong>中断描述符表就是中断向量表。</strong></p>
]]></content>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于$x^y$和$y^x$的大小判断问题的一点思考</title>
    <url>/2023/06/22/x%5Eyy%5Ex/</url>
    <content><![CDATA[<h3 id="关于xy和yx的大小判断问题的一点思考">关于<span
class="math inline">\(x^y\)</span>和<span
class="math inline">\(y^x\)</span>的大小判断问题的一点思考</h3>
<p>不妨令<span class="math inline">\(x &lt; y\)</span>。</p>
<p>则设<span class="math inline">\(x = a,y = a + b,(a &gt; 0,b &gt;
0)\)</span>。 <span class="math display">\[
a^{a + b} &gt; (a + b)^a
\]</span> <span class="math display">\[
\Leftrightarrow a &gt; (a + b) ^ {\frac a {a + b}}
\]</span> <span class="math display">\[
\Leftrightarrow a &gt; (a + b) ^ {(1 - \frac b{a + b})}
\]</span> <span class="math display">\[
\Leftrightarrow a &gt; (a + b) / ((a+b)^{\frac b{a + b}})
\]</span></p>
<p><span class="math display">\[
\Leftrightarrow (a+b)^{\frac b{a + b}} &gt; (1 + \frac ba)
\]</span></p>
<p><span class="math display">\[
\Leftrightarrow a + b &gt; (1 + \frac ba) ^ {\frac {a + b}b}
\]</span></p>
<p><span class="math display">\[
\Leftrightarrow a + b &gt; (1 + \frac ba) ^ \frac ab  \times \frac{a +
b}{a}
\]</span></p>
<p><span class="math display">\[
\Leftrightarrow a &gt; (1 + \frac ba) ^ \frac ab
\]</span></p>
<p>接下来对<span class="math inline">\(a\)</span>,<span
class="math inline">\(b\)</span>进行分类讨论：</p>
<ul>
<li><p><span class="math inline">\(a &gt; b\)</span>。则<span
class="math inline">\((1 + \frac ba) ^ \frac ab &lt;
e\)</span>，所以<span class="math inline">\(a\)</span>只要大于<span
class="math inline">\(e\)</span>，那么<span class="math inline">\(x^y
&gt; y^x\)</span>.若<span class="math inline">\(a &lt;=
2\)</span>，那么<span class="math inline">\(x^y &lt;
y^x\)</span>.</p></li>
<li><p><span class="math inline">\(a = b\)</span>。则<span
class="math inline">\((1 + \frac ba) ^ \frac ab = 2\)</span>,<span
class="math inline">\(a\)</span>只要大于2，<span
class="math inline">\(x^y &gt; y^x\)</span>.</p></li>
<li><p><span class="math inline">\(a &lt; b\)</span>。则<span
class="math inline">\((1 + \frac ba) ^ \frac ab = (1 + k)^\frac 1k ,(k
&gt; 1)\)</span>,此时易证<span class="math inline">\((1 + k)^\frac 1k
&lt; 2 ,(k &gt; 1)\)</span>。</p>
<blockquote>
<p>反证法证明该结论：设<span class="math inline">\((1 + k)^\frac 1k = v
(v \ge 2)\)</span>,则<span class="math inline">\(v^k = 1 +
k\)</span>。当<span class="math inline">\(v = 2,k = 1时\)</span>,<span
class="math inline">\(v^1 = 2 = 1 +
k\)</span>，而指数函数增长迅速，所以当<span class="math inline">\(v =
2,k &gt; 1\)</span>时，<span class="math inline">\(v^k &gt; 1 +
k\)</span>。而<span class="math inline">\(v \ge 2\)</span>,所以<span
class="math inline">\(v^k &gt; 2^k &gt; 1 +
k\)</span>，两者不可能相等。</p>
</blockquote>
<p>所以此时只要<span class="math inline">\(a \ge
2\)</span>，即可保证<span class="math inline">\(x^y &gt;
y^x\)</span>.</p></li>
</ul>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>初心</title>
    <url>/2023/06/12/%E5%88%9D%E5%BF%83/</url>
    <content><![CDATA[<p>​
希望能够幸福地做人，合理地度日，内心安定平和，即使身处逆境也始终保持追求。同时也希望能够通过文字与各位交流这方面的经验，于苦难中彼此慰藉。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论</title>
    <url>/2025/01/01/%E6%A6%82%E7%8E%87%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="概率论">概率论</h3>
<h4 id="泊松分布">1. 泊松分布</h4>
<p><span class="math inline">\(\hspace{1cm}\)</span> 定义为<span
class="math inline">\(P(x=k) = \frac{\lambda
^k}{k!}e^{-\lambda}\)</span>，<span class="math inline">\(\lambda &gt;
0\)</span>，也可以记作<span class="math inline">\(X\)</span> ~ <span
class="math inline">\(P(\lambda)\)</span></p>
<p><span class="math inline">\(\hspace{1cm}\)</span>
对于一个二项分布<span class="math inline">\(B(n,p)\)</span>，如果<span
class="math inline">\(n\)</span>比较大，<span
class="math inline">\(np\)</span>适中（<span class="math inline">\(n \ge
100， np \le 10\)</span>）那么可以把二项分布<span
class="math inline">\(B(n,p)\)</span>近似为<span
class="math inline">\(P(np)\)</span></p>
<h4 id="超几何分布">2. 超几何分布</h4>
<p><span class="math inline">\(\hspace{1cm}\)</span> 定义为<span
class="math inline">\(H(N,M,n)\)</span>，表示从有限<span
class="math inline">\(N\)</span>个物品中（其中包含<span
class="math inline">\(M\)</span>个指定种类的物件）中抽出<span
class="math inline">\(n\)</span>个物件，成功抽出该指定种类的物件的次数（不放回）</p>
<h4 id="均匀分布">3. 均匀分布</h4>
<p><span class="math inline">\(\hspace{1cm}\)</span> 即在<span
class="math inline">\([a,b]\)</span>范围内等概率分布的情况，记作<span
class="math inline">\(X\)</span> ~ <span
class="math inline">\(U(a,b)\)</span></p>
<h4 id="指数分布">4. 指数分布</h4>
<p><span class="math inline">\(\hspace{1cm}\)</span> 其概率密度函数为
<span class="math display">\[
f(x) = \begin{cases}\lambda e^{-\lambda x}\ \ \ \ x &gt; 0\\ 0 \ \ \ \ \
\ \ \ \ \ \ \ x \le 0 \end{cases}
\]</span> <span class="math inline">\(\hspace{1cm}\)</span> 记作<span
class="math inline">\(X\)</span> ~ <span
class="math inline">\(Exp(\lambda)\)</span></p>
<h4 id="几何分布">5. 几何分布</h4>
<p><span class="math inline">\(\hspace{1cm}\)</span> 定义为<span
class="math inline">\(P(X = k) = (1 - p)^{k - 1} \times
p\)</span>，也可记作<span class="math inline">\(X\)</span> ~ <span
class="math inline">\(G(p)\)</span>，表示第<span
class="math inline">\(k\)</span>次刚好第一次发生概率为<span
class="math inline">\(p\)</span>的事</p>
<h4 id="正态分布">6. 正态分布</h4>
<p><span class="math inline">\(\hspace{1cm}\)</span> 其密度函数记为
<span class="math display">\[
\varphi(x) = \frac 1{\sqrt{2\pi} \sigma}e^{-\frac{(x -
\mu)^2}{2\sigma^2}}
\]</span> <span class="math inline">\(\hspace{1cm}\)</span> 记作<span
class="math inline">\(X\)</span> ~ <span class="math inline">\(N(\mu,
\sigma^2)\)</span></p>
<p><span class="math inline">\(\hspace{1cm}\)</span> 其分布函数记为<span
class="math inline">\(\Phi(x) = \int_{-\infty}^x \phi(t) dt\)</span></p>
<p><span class="math inline">\(\hspace{1cm}\)</span> 当<span
class="math inline">\(\mu = 0, \sigma =
1\)</span>时，认为是标准正态分布，其概率密度函数记为<span
class="math inline">\(\varphi_0(x)\)</span>，分布函数记为<span
class="math inline">\(\Phi_0(x)\)</span></p>
<p><span class="math inline">\(\hspace{1cm}\)</span>
对于任何任意一个<span class="math inline">\(\varphi(x)\)</span>，有<span
class="math inline">\(\varphi(x) = \frac 1 \sigma \varphi_0(\frac {x -
\mu}{\sigma})\)</span>，以及<span class="math inline">\(\Phi(x) =
\Phi_0(\frac{x - \mu}{\sigma})\)</span></p>
<h3 id="多维随机变量相关">多维随机变量相关</h3>
<h4
id="多维随机变量的联合分布函数以及边缘分布函数对于离散型和连续型均适用">1.多维随机变量的联合分布函数，以及边缘分布函数（对于离散型和连续型均适用）</h4>
<p><span class="math inline">\(\hspace{1cm}\)</span>
仿照单元模式，我们有如下定义：<span class="math inline">\(F(x,y) = P(X
\le x, Y \le y)\)</span> 为<span
class="math inline">\((X,Y)\)</span>的联合分布函数</p>
<p><span class="math inline">\(\hspace{1cm}\)</span>
根据定义，容易证明</p>
<p><span class="math display">\[
P(x_1 &lt; X \le x_2, y_1 &lt; Y \le y_2) = F(x_2,y_2) - F(x_1,y_2) -
F(x_2,y_1) + F(x_1,y_1)
\]</span></p>
<p><span class="math inline">\(\hspace{1cm}\)</span> 注意到<span
class="math inline">\(F(x,y)\)</span>有如下性质：</p>
<p><span class="math display">\[
F(-\infty,y) = F(x, -\infty) = 0
\]</span></p>
<p><span class="math display">\[
F(-\infty,-\infty) = 0, F(+\infty,+\infty) = 1
\]</span></p>
<p><span class="math inline">\(\hspace{1cm}\)</span>
定义边缘分布函数：称<span
class="math inline">\(F_X(x),F_Y(y)\)</span>分别为<span
class="math inline">\((X,Y)\)</span>关于<span
class="math inline">\(X\)</span>和<span
class="math inline">\(Y\)</span>的边缘分布函数，其中<span
class="math inline">\(F_X(x) = F(x,+\infty)\)</span>，<span
class="math inline">\(F_Y(y) = F(y, +\infty)\)</span>。</p>
<h4 id="多维随机变量的联合概率密度以及边缘概率密度连续型">2.
多维随机变量的联合概率密度以及边缘概率密度（连续型）</h4>
<p><span class="math inline">\(\hspace{1cm}\)</span> 若存在二元函数<span
class="math inline">\(f(x,y)\)</span>使得<span
class="math inline">\(\int_{-\infty}^x \int_{-\infty}^y f(u,v)dudv =
F(x,y)\)</span>，则称<span
class="math inline">\(f(x,y)\)</span>为联合概率密度</p>
<p><span class="math inline">\(\hspace{1cm}\)</span>
定义边缘概率密度函数：称<span class="math inline">\(f_X(x),
f_Y(y)\)</span>分别为<span class="math inline">\((X,Y)\)</span>关于<span
class="math inline">\(X\)</span>和<span
class="math inline">\(Y\)</span>的边缘密度函数，其中<span
class="math inline">\(f_X(x) =
\int_{-\infty}^{+\infty}f(x,y)dy\)</span>, <span
class="math inline">\(f_Y(y) =
\int_{-\infty}^{+\infty}f(x,y)dx\)</span></p>
<p>​</p>
<h4 id="多维随机变量的联合分布列以及边缘分布列离散型">3.
多维随机变量的联合分布列以及边缘分布列（离散型）</h4>
<p><span class="math inline">\(\hspace{1cm}\)</span> 若<span
class="math inline">\((X,Y)\)</span>均是离散的，那么定义<span
class="math inline">\(p_{ij} =P(X = x_i, Y =
y_i)\)</span>为联合分布列</p>
<p><span class="math inline">\(\hspace{1cm}\)</span> 同时定义<span
class="math inline">\(p_{i·} = \sum_j p_{ij}\)</span>为<span
class="math inline">\((X,Y)\)</span>关于<span
class="math inline">\(X\)</span>的边缘分布列，<span
class="math inline">\(p_{·j} =\sum _i p_{ij}\)</span> 为<span
class="math inline">\((X,Y)\)</span>关于<span
class="math inline">\(Y\)</span>的边缘分布列</p>
<h4 id="多维变量的分布">4. 多维变量的分布</h4>
<p><span class="math inline">\(\hspace{1cm}\)</span> 设<span
class="math inline">\(Z = \frac XY\)</span>，且<span
class="math inline">\(f(x,y)\)</span>表示变量<span
class="math inline">\(X,Y\)</span>的联合概率密度函数，则有： <span
class="math display">\[
f_Z(z) = \int_{-\infty}^{+\infty} |y| f(yz,y)dy
\]</span></p>
<h3 id="期望方差协方差">期望，方差，协方差</h3>
<ul>
<li><p>常见分布的期望和方差：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>E:期望</th>
<th>D：方差</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(U(a,b)\)</span></td>
<td><span class="math inline">\(\frac {a + b}2\)</span></td>
<td><span class="math inline">\(\frac{(b - a)^2}{12}\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(P(\lambda)\)</span></td>
<td><span class="math inline">\(\lambda\)</span></td>
<td><span class="math inline">\(\lambda\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(E(\lambda)\)</span></td>
<td><span class="math inline">\(\frac 1\lambda\)</span></td>
<td><span class="math inline">\(\frac 1{\lambda^2}\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(G(p)\)</span></td>
<td><span class="math inline">\(\frac 1p\)</span></td>
<td><span class="math inline">\(\frac q{p^2}\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(N(\mu, \sigma^2)\)</span></td>
<td><span class="math inline">\(\mu\)</span></td>
<td><span class="math inline">\(\sigma^2\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(B(n,p)\)</span></td>
<td><span class="math inline">\(np\)</span></td>
<td><span class="math inline">\(npq\)</span></td>
</tr>
</tbody>
</table>
<p>注：<span class="math inline">\(E(\lambda)\)</span>为指数分布，<span
class="math inline">\(G(p)\)</span>为几何分布，<span
class="math inline">\(q = 1 - p\)</span></p></li>
<li><p>切比雪夫不等式： 对于一切分布<span
class="math inline">\(X\)</span>，有： <span class="math display">\[
P(|X - EX| &gt; \varepsilon) \le \frac {DX}{\varepsilon^2}
\]</span></p></li>
<li><p>注意：如果随机变量<span
class="math inline">\(X,Y\)</span>满足<span class="math inline">\(E(XY)
= E(X)E(Y)\)</span>那么不能说明<span
class="math inline">\(X\)</span>和<span
class="math inline">\(Y\)</span>是独立的！</p></li>
<li><p>对于任意随机变量<span
class="math inline">\(X_1,X_2,...,X_n\)</span>以及任意常数<span
class="math inline">\(k_0,k_1,...,k_n\)</span>，我们有： <span
class="math display">\[
D(k_0 + k_1X_1+ k_2X_2 + ... + k_nX_n) = \sum_{i = 1}^n{k_i}^2DX_i + 2
\sum_{1 \le i &lt; j \le n}k_ik_jCov(X_i,X_j)
\]</span></p></li>
<li><p>Cauchy-schwarz inequation: <span class="math display">\[
EX^2 \times EY^2 \ge (E[XY])^2
\]</span></p></li>
<li><p>最小二乘法拟合：对于随机变量<span
class="math inline">\(X,Y\)</span>，尝试用<span class="math inline">\(y
= \hat{a}x + \hat{b}\)</span>拟合，那么最好的拟合直线中: <span
class="math display">\[
\hat{a} = \rho_{XY} \sqrt{\frac {DY}{DX} }, \hat{b} = EY - \hat{a}EX
\]</span></p></li>
<li><p>若<span class="math inline">\((X,Y)\)</span>服从二维正态分布<span
class="math inline">\(N(\mu_1,\mu_2,{\sigma_1}^2,{\sigma_2}^2,\rho)\)</span>，那么<span
class="math inline">\(Cov(X,Y) = \sigma_1\sigma_2\rho\)</span></p></li>
<li><p>条件期望的概念：书p69开始，注意：<span
class="math inline">\(E(X|Y)\)</span>是一个关于<span
class="math inline">\(Y\)</span>的函数，也是一个随机变量，而<span
class="math inline">\(E(X|Y = y)\)</span>是一个常数。全期望公式： <span
class="math display">\[
E(X) = E[E(X|Y)]
\]</span></p></li>
</ul>
<h3 id="数理统计部分">数理统计部分</h3>
<ul>
<li><p><strong>样本方差</strong>的定义：设有<span
class="math inline">\(n\)</span>个样本<span
class="math inline">\(X_1,X_2,...,X_n\)</span>，则定义样本方差 <span
class="math display">\[
S^2 = \frac 1{n - 1} \sum_{i = 1}^n(X_i - \bar{X})^2
\]</span> 其中： <span class="math display">\[
\bar{X} = \frac 1n \sum_{i = 1}^nX_i
\]</span></p></li>
<li><p>设<span
class="math inline">\(n\)</span>个样本都是独立同分布的，且每个样本作为随机变量均值为<span
class="math inline">\(\mu\)</span>,方差为<span
class="math inline">\(\sigma^2\)</span>，则： <span
class="math display">\[
ES^2 =E(\frac 1{n - 1} \sum_{i = 1}^n(X_i - \bar{X})^2) = \frac 1{n - 1}
\sum_{i = 1}^n(E^2(X_i) - 2E(X_i\bar{X}) + E^2(\bar{x}))\\ = \frac 1{n -
1} \sum_{i = 1}^n(\mu^2 + \sigma^2 + \mu^2 + \frac 1n \sigma^2 -
2E(X_i\bar{X}))\\
\because E(X_i\bar{X}) = \frac 1nE(\sum_{1 \le j\le n, j \neq i}X_iX_j)
+ \frac 1nE({X_i}^2) = \frac 1n\sum_{1 \le j\le n, j \neq i}E(X_i)E(X_j)
+ \frac 1nE({X_i}^2)\\ = \mu^2 + \frac 1n \sigma^2\\
\therefore ES^2 = \frac 1{n - 1} \times n \times \frac{n - 1}n\sigma^2 =
\sigma^2
\]</span></p></li>
<li><p>设<span class="math inline">\(\chi^2\)</span> ~ <span
class="math inline">\(\chi^2(n)\)</span>，则当<span
class="math inline">\(n\)</span>足够大时，<span
class="math inline">\(\sqrt{2\chi^2}\)</span>近似服从正态分布<span
class="math inline">\(N(\sqrt{2n-1},1)\)</span></p></li>
<li><p><strong>t分布</strong>：若<span class="math inline">\(X\)</span>
~ <span class="math inline">\(N(0,1)\)</span>, <span
class="math inline">\(Y\)</span> ~ <span
class="math inline">\(\chi^2(N)\)</span>，且<span
class="math inline">\(X\)</span>和<span
class="math inline">\(Y\)</span>相互独立，那么定义<span
class="math inline">\(T\)</span> ~ <span class="math inline">\(t(n) =
\frac{X}{\sqrt{Y/n}}\)</span>为<strong>t分布</strong>.</p>
<p>当<span class="math inline">\(n \to +\infty\)</span>时，<span
class="math inline">\(t(n)\)</span> 可近似为 <span
class="math inline">\(N(0,1)\)</span></p></li>
<li><p><strong>F分布：</strong>若<span class="math inline">\(X\)</span>
~ <span class="math inline">\(\chi^2(n_1)\)</span>， <span
class="math inline">\(Y\)</span> ~ <span
class="math inline">\(\chi^2(n_2)\)</span>，且<span
class="math inline">\(X\)</span>和<span
class="math inline">\(Y\)</span>相互独立，那么定义<span
class="math inline">\(F(n_1,n_2) =
\frac{X/{n_1}}{Y/_{n_2}}\)</span>为<strong>F分布</strong></p>
<p>​ 若<span class="math inline">\(F\)</span> ~ <span
class="math inline">\(F(n_1,n_2)\)</span>,则有$1F $ ~ <span
class="math inline">\(F(n_2,n_1)\)</span>。同时我们有：<span
class="math inline">\(F_{\alpha}(n_2,n_1) = \frac 1{F_{1 -
\alpha}(n_1,n_2)}\)</span></p></li>
<li><p>假设<span
class="math inline">\(X_1,X_2,...,X_n\)</span>均服从<span
class="math inline">\(N(\mu,\sigma^2)\)</span>且相互独立，设<span
class="math inline">\(\bar{X} = \frac 1n \sum_{i = 1}^n
{X_i}\)</span>，<span class="math inline">\(S^2 = \frac 1n \sum_{i =
1}^n(X_i - \bar{X})^2\)</span>，那么：</p>
<ul>
<li>$ _{i = 1}^n (X_i - )^2$ ~ <span
class="math inline">\(\chi^2(n)\)</span></li>
<li>$_{i = 1}^n (X_i - {X})^2 $ ~ <span class="math inline">\(\chi^2 (n
- 1)\)</span> 这条等价为<span class="math inline">\((n - 1)\frac
{S^2}{\sigma^2}\)</span> ~ <span class="math inline">\(\chi^2(n -
1)\)</span></li>
<li><span class="math inline">\(\frac{\bar{X} - \mu}
{\sigma}\sqrt{n}\)</span> ~ <span
class="math inline">\(N(0,1)\)</span>；<br />
</li>
<li><span class="math inline">\(\frac{\bar{X} - \mu}{S}\sqrt{n}\)</span>
~ <span class="math inline">\(t(n - 1)\)</span>；
（这里的S表示标准差，即<span
class="math inline">\(\sqrt{S^2}\)</span>，同时我们可以比较上下发现，当<span
class="math inline">\(n \to \infty\)</span>时，<span
class="math inline">\(t(n - 1) \to N(0,1)\)</span>）</li>
</ul></li>
<li><p>p96 推论6.3 考前看一下，难记</p></li>
<li><p>在正态分布中，不相关和独立是等价的，这是一条很强的结论</p></li>
<li><p>正态分布随机抽样得到<span
class="math inline">\(X_1,X_2,...,X_n\)</span>。那么有<span
class="math inline">\(S^2\)</span>与<span
class="math inline">\(\overline{X}\)</span>独立，且有<span
class="math inline">\(\tilde{S}\)</span>与<span
class="math inline">\(\overline{X}\)</span>独立。</p></li>
</ul>
<h3 id="参数估计部分">参数估计部分</h3>
<p><span class="math inline">\(\hspace{1cm}\)</span>
这部分主要用于处理已经知道一系列样本，要用这些样板来估计分布函数里面的一些参数的问题。</p>
<ul>
<li><p>矩估计：</p>
<ul>
<li><p>若只有一个参数要估计，那只需要用一阶矩来估计即可；
如果有n个参数要估计，那么用前n阶矩来估计</p></li>
<li><p>用第<span class="math inline">\(k\)</span>阶矩来估计的方法：</p>
<ul>
<li>首先计算出总体的<span
class="math inline">\(k\)</span>阶原点矩，这等于<span
class="math inline">\(E(X^k)\)</span>，这应该是一个关于待估计参数的函数</li>
<li>然后计算出样本的<span
class="math inline">\(k\)</span>阶原点矩，这等于<span
class="math inline">\(\frac 1n \sum_{i = 1}^n {X_i}^k\)</span>
，这算出来是一个确定的数</li>
<li>令样本的<span
class="math inline">\(k\)</span>阶原点矩等于总体的<span
class="math inline">\(k\)</span>阶原点矩，得到一个方程用来解待估计的参数</li>
</ul></li>
<li><p>更加一般化地说，就是我们可以用样本的<span
class="math inline">\(k\)</span>阶原点矩作为总体的<span
class="math inline">\(k\)</span>阶原点矩。例如，我们知道样本的<span
class="math inline">\(1\)</span>阶原点矩是<span
class="math inline">\(a\)</span>，样本的<span
class="math inline">\(2\)</span>阶原点矩是<span
class="math inline">\(b\)</span>，现在要求样本的标准差的矩估计。</p>
<p>那么，我们就可以认为<span class="math inline">\(EX = a\)</span>,
<span class="math inline">\(EX^2 = b\)</span>，于是<span
class="math inline">\(D = EX^2 -(EX)^2 = b -
a^2\)</span>，所以我们就认为<span class="math inline">\(\sqrt{b -
a^2}\)</span>是样本的标准差的矩估计。</p></li>
<li><p>我们有如下记号约定：对于一个样本<span
class="math inline">\((X_1,X_2,...,X_n)\)</span>，令 <span
class="math inline">\(\tilde{S}^2 = \frac 1n \sum_{i = 1}^n (X_i -
\overline{X})^2\)</span></p></li>
<li><p>在矩估计法中，认为<span class="math inline">\(DX =
\tilde{S}^2\)</span></p>
<p>证明如下： <span class="math display">\[
\tilde{S}^2 =\frac 1n \sum_{i = 1}^n (X_i - \overline{X})^2 \\ =
\frac 1n \sum_{i = 1}^n{X_i}^2 - \frac 2n \sum_{i =
1}^n{X_i}\overline{X} + \overline{X}^2\\ =  \frac 1n \sum_{i =
1}^n{X_i}^2 - 2\overline{X}^2 + \overline{X}^2 = \frac 1n \sum_{i =
1}^n{X_i}^2 - \overline{X}^2\\ = EX^2 - (EX)^2 = DX
\]</span></p></li>
</ul></li>
<li><p>最大似然估计</p>
<p>即为要让参数取该估计值时，样本发生的概率最大</p></li>
<li><p>设<span class="math inline">\(\hat{\theta} =
\hat{\theta}(X_1,X_2,...,X_n)\)</span>是参数<span
class="math inline">\(\theta\)</span>的估计量，若对于任意的<span
class="math inline">\(\theta \in \Theta\)</span>，都有： <span
class="math display">\[
E(\hat{\theta}) = \theta
\]</span> 那么称<span class="math inline">\(\hat{\theta}\)</span>是<span
class="math inline">\(\theta\)</span>的无偏估计。</p>
<p>设总体方差<span
class="math inline">\(DX=\sigma^2\)</span>存在，那么<span
class="math inline">\(S^2 = \frac 1{n - 1} \sum_{i = 1}^n (X_i -
\overline{X})^2\)</span>是<span
class="math inline">\(\sigma^2\)</span>的无偏估计，而<span
class="math inline">\(\tilde{S}^2 = \frac 1n \sum_{i = 1}^n(X_i -
\overline{X})^2\)</span>是<span
class="math inline">\(\sigma^2\)</span>的有偏估计。</p></li>
</ul>
<h3 id="概率论好题整理">概率论好题整理</h3>
<ol type="1">
<li><p>若<span class="math inline">\(X,Y\)</span>独立，且<span
class="math inline">\(X\)</span> ~ <span
class="math inline">\(P(\lambda_1)\)</span>,<span
class="math inline">\(Y\)</span> ~ <span
class="math inline">\(P(\lambda_2)\)</span>。</p>
<ol type="1">
<li>证明<span class="math inline">\(X + Y\)</span> ~ <span
class="math inline">\(P(\lambda_1 + \lambda_2)\)</span>;
（2）求在已知<span class="math inline">\(X + Y = m\)</span>的条件下<span
class="math inline">\(X\)</span>的分布</li>
</ol></li>
<li><p>已知随机变量<span class="math inline">\(X\)</span>和<span
class="math inline">\(Y\)</span>相互独立，且都服从<span
class="math inline">\(N(0,1)\)</span>，求<span
class="math inline">\(E[max\{X,Y\}]\)</span></p></li>
<li><p>已知<span class="math inline">\(X\)</span> ~ <span
class="math inline">\(N(\mu, \sigma ^2)\)</span>，求<span
class="math inline">\(DX\)</span></p>
<p>首先<span class="math inline">\(EX = \mu\)</span>, 然后： <span
class="math display">\[
DX = E((X - EX)^2) = E((X - \mu)^2) = \int_{-\infty}^{+\infty} \frac 1
{\sqrt{2\pi}\sigma}e^{-\frac {(x - \mu)^2}{2\sigma ^2}}\times (x -
\mu)^2 dx\\ = \int_{-\infty}^{+\infty} \frac 1 {\sqrt{2\pi}\sigma}
e^{\frac{-x^2}{2\sigma^2} }\times x^2 dx = \int_{-\infty}^{+\infty}
\frac 1 {\sqrt{2\pi}\sigma} e^{-(\frac x{\sqrt 2 \sigma})^2} \times
(\frac x{\sqrt 2 \sigma})^2d(\frac {x}{\sqrt 2 \sigma}) \times 2\sqrt 2
\sigma ^3\\ = \frac{2\sigma ^2}{\sqrt{\pi}} \int_{-\infty}^{+\infty}
e^{-x^2} x^2dx
\]</span></p></li>
</ol>
<p>​ 考察积分<span
class="math inline">\(\int_{-\infty}^{+\infty}e^{-x^2}x^2dx\)</span>：
<span class="math display">\[
\int_{-\infty}^{+\infty} e^{-x^2}dx = \left.
xe^{-x^2}\right|_{-\infty}^{+\infty}  +
2\int_{-\infty}^{+\infty}e^{x^2}x^2 dx = \sqrt{\pi}
\]</span> ​ 于是： <span class="math display">\[
\int_{-\infty}^{+\infty}e^{x^2}x^2 dx =\frac {\sqrt \pi}2
\]</span> ​ 所以: <span class="math display">\[
DX = \sigma^2
\]</span></p>
<ol start="4" type="1">
<li>已知<span class="math inline">\(X\)</span> ~ <span
class="math inline">\(N(0,\sigma^2)\)</span>, <span
class="math inline">\(Y\)</span> ~ <span
class="math inline">\(N(0,\sigma ^2)\)</span>，求证：<span
class="math inline">\(X + Y\)</span> ~ <span class="math inline">\(N(0,
2\sigma^2)\)</span>， <span class="math inline">\(X - Y\)</span> ~ <span
class="math inline">\(N(0, 2\sigma^2)\)</span>。</li>
</ol>
<p><strong>超级强的一个结论：</strong>若<span
class="math inline">\(X\)</span> ~ <span
class="math inline">\(N(\mu_1,{\sigma_1}^2)\)</span>，<span
class="math inline">\(Y\)</span> ~ <span
class="math inline">\(N(\mu_2,{\sigma_2}^2)\)</span>，则<span
class="math inline">\(X + Y\)</span> ~ <span
class="math inline">\(N(\mu_1+\mu_2，{\sigma_1}^2+{\sigma_2}^2
)\)</span>，</p>
<p><span class="math inline">\(X - Y\)</span> ~ <span
class="math inline">\(N(\mu1 - \mu
2,{\sigma_1}^2+{\sigma_2}^2  )\)</span></p>
<ol start="5" type="1">
<li><p>设随机变量<span class="math inline">\(X\)</span>与<span
class="math inline">\(Y\)</span>相互独立，且都服从<span
class="math inline">\(N(0, \frac 12)\)</span>分布，求<span
class="math inline">\(E|X - Y|\)</span>以及<span
class="math inline">\(D|X-Y|\)</span> <span class="math display">\[
E|X-Y| = \sqrt{\frac 2 \pi}\ \ \ \ \ \ \ D|X-Y| = 1 - \frac 2 \pi
\]</span></p></li>
<li><p>设随机变量<span class="math inline">\(x\)</span>具有概率密度：
<span class="math display">\[
f(x) = \begin{cases} \frac{x^m}{m!} e^{-x}\ \ \ \ \ \ \ \ x \ge 0\\
0 \ \ \ \ \ \ \  \ \ \ \ \  \ else\end{cases}
\]</span> 其中<span
class="math inline">\(m\)</span>为正整数。请证明：<span
class="math inline">\(P(0 \le X \le 2(m + 1)) \ge \frac m{m +
1}\)</span></p>
<blockquote>
<p>hint: 实际上这个概率密度函数和欧拉给出的 x!
的连续函数的被积函数很像</p>
</blockquote></li>
<li><p>设随机变量<span
class="math inline">\(X,Y\)</span>独立，且分别服从参数为<span
class="math inline">\(\lambda\)</span>和<span
class="math inline">\(\mu\)</span>的泊松分布，求<span
class="math inline">\(E(X|X + Y = m)\)</span></p>
<blockquote>
<p><span class="math inline">\(ans:\frac{m\lambda}{\lambda +
\mu}\)</span></p>
</blockquote></li>
<li><p>假设随机变量<span class="math inline">\(X_1\)</span>在<span
class="math inline">\([0,1]\)</span>上有均匀分布,<span
class="math inline">\(X_i\)</span>在<span
class="math inline">\([X_{i-1},X_{i-1}+1]\)</span>上有均匀分布，其中<span
class="math inline">\(i = 2,3,...,n\)</span>，求<span
class="math inline">\(EX_n\)</span></p>
<p>解：首先<span class="math inline">\(E(X_i|X_{i - 1}) = X_{i - 1} +
\frac 12\)</span>，根据全期望公式，有</p>
<p><span class="math display">\[
E(X_i) = E(E(X_i|X_{i - 1})) = E(x_{i - 1} + \frac 12) = EX_{i - 1} +
\frac 12
\]</span> 而<span class="math inline">\(E_1 = \frac
12\)</span>，所以<span class="math inline">\(E_n = \frac
n2\)</span></p></li>
<li><p>已知<span class="math inline">\(X\)</span> ~ <span
class="math inline">\(N(0,1)\)</span>，求<span
class="math inline">\(E(X^2),D(X^2)\)</span> <span
class="math display">\[
E(X^2) = E^2(X) + D(X) = 1\\
E(X^4) = \int_{-\infty}^{+\infty}\frac
1{\sqrt{2\pi}}e^{-\frac{x^2}2}x^4dx\\
while\ \ \ \int_{-\infty}^{+\infty}e^{-x^2}x^4dx = \frac 34 \sqrt{\pi}\
\ (This \ \ is \ \ similar \ \  to \ \ calculating \ \
\int_{-\infty}^{+\infty}e^{-x^2}x^2 dx)\\
\therefore E(X^4) = 3\\
\therefore D(X^2) = E(X^4)-E^2(X^2) = 3 - 1 = 2
\]</span></p></li>
<li><p>设总体<span class="math inline">\(B\)</span> ~ <span
class="math inline">\(B(1,p)\)</span>,<span
class="math inline">\(p\)</span>为未知参数，<span
class="math inline">\((X_1,X_2,X_3,...,X_n)\)</span> 为来自总体<span
class="math inline">\(X\)</span>的样本，求<span
class="math inline">\(p\)</span>的极大似然估计</p>
<p>第一种做法是<span class="math inline">\(L(\theta) = \prod(X_ip +
(1-X_i)(1-p))\)</span>，这种后续取对然后求驻点是做不下去的</p>
<p>需要写成<span class="math inline">\(L(\theta) = \prod(p^{X_i}(1 -
p)^{1 - X_i})\)</span>，然后后续取对然后求驻点可以做</p></li>
<li><p>设总体<span class="math inline">\(X\)</span>的密度函数为： <span
class="math display">\[
f(x) = \begin{cases}\frac 1 \theta e^{-\frac{x - \mu}\theta}\ \ \ \ x
\ge \mu \\ 0 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ x &lt; \mu  \\ \end{cases}
\]</span> 其中<span class="math inline">\(\theta &gt; 0\)</span>，
求未知参数<span class="math inline">\(\mu,
\theta\)</span>的矩估计量</p></li>
</ol>
<p>注意到：<span class="math inline">\(X - \mu\)</span> ~ <span
class="math inline">\(E(\frac 1\theta)\)</span>，</p>
<p>所以：<span class="math inline">\(E(X - \mu)\)</span> = <span
class="math inline">\(\theta\)</span>, <span class="math inline">\(D(X -
\mu) = \theta^2\)</span>， 所以：<span class="math inline">\(EX = \theta
+ \mu, DX = \theta ^2\)</span>， 所以：<span
class="math inline">\(\overline{X} = \theta + \mu, \tilde{S}^2 =
\theta^2\)</span> 所以：<span class="math inline">\(\theta = \tilde{S},
\mu = \overline{X} - \tilde{S}\)</span></p>
<ol start="12" type="1">
<li>若<span class="math inline">\(X\)</span>与<span
class="math inline">\(Y\)</span>不相关，是否有<span
class="math inline">\(f(X)\)</span>与<span
class="math inline">\(g(Y)\)</span>不相关？</li>
<li>若<span
class="math inline">\(X_1,X_2,...,X_n\)</span>独立同分布，是否有<span
class="math inline">\(\overline{X}\)</span>与<span
class="math inline">\(S^2\)</span>不相关？</li>
</ol>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>高斯消元</title>
    <url>/2023/06/27/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/</url>
    <content><![CDATA[<h1 id="高斯消元">高斯消元</h1>
<p>高斯消元适用于求解线性方程组。</p>
<p>一般的，对于线性方程组： <span class="math display">\[
a_{1,1}x_1 + a_{1,2}x_2 + a_{1,3}x_3 + ……a_{1,n}x_n = b_1
\]</span> <span class="math display">\[
a_{2,1}x_1 + a_{2,2}x_2 + a_{2,3}x_3 + ……a_{2,n}x_n = b_2
\]</span></p>
<p><span class="math display">\[
……
\]</span></p>
<p><span class="math display">\[
a_{n,1}x_1 + a_{n,2}x_2 + a_{n,3}x_3 + ……a_{n,n}x_n = b_n
\]</span></p>
我们用下面这个矩阵来表示这个线性方程组： $$ {
<span class="math display">\[\begin{array}{ccccc|c}
a_{1,1} &amp; a_{1,2} &amp; a_{1,3} &amp; \cdots &amp; a_{1,n}&amp;b_1\\
a_{2,1} &amp; a_{2,2} &amp; a_{2,3} &amp; \cdots &amp; a_{2,n}&amp;b_2\\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp;
\vdots\\
a_{n,1} &amp; a_{n,2} &amp; a_{n,3} &amp; \cdots &amp; a_{n,n}&amp;b_n\\

\end{array}\]</span>
<p>} $$ 我们循环一个变量<span class="math inline">\(i\)</span>（从<span
class="math inline">\(1\)</span>到<span
class="math inline">\(n\)</span>）</p>
<p>先在矩阵中找到一行（设这行是第<span
class="math inline">\(x\)</span>行），使得<span
class="math inline">\(a_{x,1},a_{x,2},……,a_{x,i-1}\)</span>都为<span
class="math inline">\(0\)</span>，但<span class="math inline">\(a_{x,i}
= 0\)</span>。</p>
<p>然后用这一行矩阵，用简单行变换的方式将矩阵其他行的第<span
class="math inline">\(i\)</span>项的系数消为0。</p>
<p>最后我们就得到一个“阶梯矩阵”，然后就可以愉快地求解了。</p>
<ul>
<li><p>Code</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> a[maxn][maxn],b[maxn];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i][j]);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;b[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=i; j&lt;=n; j++)</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">fabs</span>(a[j][i]) &gt; <span class="number">1e-10</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>; k&lt;=n; k++)</span><br><span class="line">					<span class="built_in">swap</span>(a[i][k],a[j][k]);</span><br><span class="line">				<span class="built_in">swap</span>(b[i],b[j]);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j == i)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="type">double</span> rate = a[j][i] / a[i][i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>; k&lt;=n; k++)</span><br><span class="line">				a[j][k] -= rate * a[i][k];</span><br><span class="line">			b[j] -= rate * b[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;x%d = %.2lf\n&quot;</span>,i,b[i] / a[i][i]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
</ul>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记</title>
    <url>/2023/03/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="机器学习笔记">机器学习笔记</h3>
<h4 id="安装pytorch">1. 安装Pytorch</h4>
<p>​ 在<a
href="https://pytorch.org/get-started/locally/">这里</a>选择你的选项，然后在命令行中打<code>pytorch</code>官网提供的命令，打完之后如果遇到了错误，那么考虑是不是你的<code>python</code>版本过高。访问<a
href="https://pytorch.org/get-started/locally/#windows-python">Start
Locally |
PyTorch</a>这里来确认<code>pytorch</code>是否支持你的<code>python</code>版本。</p>
<p>​</p>
<h4 id="动手学深度学习笔记">2. 《动手学深度学习》笔记</h4>
<h5 id="数据操作">2.1 数据操作</h5>
<ul>
<li><p>注意：两个张量如果可以广播，那么：</p>
<ul>
<li>每个张量至少有一个维度。</li>
<li>迭代维度尺寸时，从<strong>尾部</strong>的维度开始，维度尺寸 ​
或者<strong>相等</strong>， ​ 或者<strong>其中一个张量的维度尺寸为
1</strong> ， ​ 或者<strong>其中一个张量不存在这个维度</strong></li>
</ul>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1：相同形状的张量总是可广播的，因为总能满足以上规则。</span></span><br><span class="line">x = torch.empty(<span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>)</span><br><span class="line">y = torch.empty(<span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：不可广播（ a 不满足第一条规则）。</span></span><br><span class="line">a = torch.empty((<span class="number">0</span>,))</span><br><span class="line">b = torch.empty(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3：m 和 n 可广播：</span></span><br><span class="line">m = torch.empty(<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">n = torch.empty(   <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 倒数第一个维度：两者的尺寸均为1</span></span><br><span class="line"><span class="comment"># 倒数第二个维度：n尺寸为1</span></span><br><span class="line"><span class="comment"># 倒数第三个维度：两者尺寸相同</span></span><br><span class="line"><span class="comment"># 倒数第四个维度：n该维度不存在</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例4：不可广播，因为倒数第三个维度：2 != 3</span></span><br><span class="line">p = torch.empty(<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">q = torch.empty(   <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例5：a 和 b 可广播：</span></span><br><span class="line">m = torch.arange(<span class="number">12</span>).reshape(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">n = torch.tensor(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="微积分">2.4 微积分</h5>
<ul>
<li>2.4.3的梯度没有懂，尤其是涉及矩阵的部分</li>
</ul>
<h5 id="自动微分">2.5 自动微分</h5>
<ul>
<li><p>2.5.1 一个标量函数如何对一个向量求导？</p>
<p><strong>标量</strong> y 对 n 维<strong>列</strong>向量 <span
class="math inline">\(x =
(x_1,x_2,...,x_n)^T\)</span>求导，其结果还是一个n维列向量，结果是<span
class="math inline">\((\frac {\partial y} {\partial x_1}, \frac
{\partial y} {\partial x_2} ... \frac {\partial y} {\partial
x_n})^T\)</span></p>
<p><strong>标量</strong> y 对 n 维<strong>行</strong>向量 <span
class="math inline">\(x =
(x_1,x_2,...,x_n)\)</span>求导，其结果还是一个n维行向量，结果是<span
class="math inline">\((\frac {\partial y} {\partial x_1}, \frac
{\partial y} {\partial x_2} ... \frac {\partial y} {\partial
x_n})\)</span></p></li>
</ul>
]]></content>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>卡塔兰猜想的一个特殊情况的证明</title>
    <url>/2023/06/25/%E5%8D%A1%E5%A1%94%E5%85%B0%E7%8C%9C%E6%83%B3%E7%9A%84%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E7%9A%84%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<h1
id="卡塔兰猜想的一个特殊情况的证明">卡塔兰猜想的一个特殊情况的证明</h1>
<p>命题：<span
class="math inline">\(x,y\)</span>都是正整数，求证不存在<span
class="math inline">\(x&gt;2,y&gt;3\)</span>使得<span
class="math inline">\(3^x-2^y=\pm 1\)</span></p>
<p>证：1° <span class="math inline">\(3^x-2^y = 1\)</span></p>
<p><span class="math display">\[ 3^x - 2^y = 1\]</span></p>
<p><span class="math display">\[\because x &gt; 2,y &gt;
3\\\]</span></p>
<p><span class="math display">\[\therefore 设s = x - 2,t = y - 3(s \ge
1,t \ge 1)\]</span></p>
<p><span class="math display">\[ 则3^2 \times 3^s - 2^3 \times 2^t =
1\\\]</span></p>
<p><span class="math display">\[ 9 \times 3^s-8 \times 2^t =
1\]</span></p>
<p><span class="math display">\[ \therefore 3^s = 1 + 8k,2^t = 1 + 9k (k
\in Z)\]</span></p>
<p><span class="math display">\[ \because s \ge 1,t \ge 1\]</span></p>
<p><span class="math display">\[ \therefore k \ge 1\]</span></p>
<p><span class="math display">\[ \because 3^s = 1 + 8k
（1）\]</span></p>
<p><span class="math display">\[ \therefore 3^s \equiv 1 \pmod
8\]</span></p>
<p><span class="math display">\[ 而当s = 2l(l \in Z)时，3^s \equiv 1
\pmod 8\]</span></p>
<p><span class="math display">\[\therefore 9^l = 8k + 1\]</span></p>
<p><span class="math display">\[ 又\because 2^t = 1 + 9k
(2)\]</span></p>
<p><span class="math display">\[ 且当t = 6c (c \in Z)时，2^t \equiv 1
\pmod 9\]</span></p>
<p><span class="math display">\[ \therefore 64^c = 1 + 9k
(3)\]</span></p>
<p><span class="math display">\[ 由(2),(3),有：\\ \begin{cases} k \equiv
1 \pmod 9 \\ k \equiv 7 \pmod {64}\\ \end{cases}\\ \]</span></p>
<p><span class="math display">\[所以k \equiv 199 \pmod{576}\]</span></p>
<p><span class="math display">\[ \therefore 9k + 1 \equiv 76 \pmod
{576}\]</span></p>
<p><span class="math display">\[ 由(3) \\ 则64^c = 576r + 76(r \in
Z)\]</span></p>
<p><span class="math display">\[ \because 64 | 576,64 \nmid
76\]</span></p>
<p><span class="math display">\[ \therefore 无解。 \]</span></p>
<hr />
<p>2° <span class="math inline">\(3^x - 2^y = -1\)</span></p>
<p><span class="math display">\[ 3^x - 2^y = -1\]</span></p>
<p><span class="math display">\[ 2^y - 3^x = 1\]</span></p>
<p><span class="math display">\[ 令s = y - 3,t = x - 2 \]</span></p>
<p><span class="math display">\[ 8 \times 2^s - 9 \times 3^t =
1\]</span></p>
<p><span class="math display">\[ 2^s = 8 + 9k,3^t = 7 + 8k (k\in
Z)\]</span></p>
<p><span class="math display">\[ \because 3^t = 7 + 8k\]</span></p>
<p><span class="math display">\[ \therefore 3^t \equiv 7 \pmod
8\]</span></p>
<p><span class="math display">\[
而3^t除8的余数集合为\{1,3\}\]</span></p>
<p><span class="math display">\[ \therefore 无解。\]</span></p>
<p>Q.E.D.</p>
<p>-----2020.1.18 20:50</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展欧拉定理</title>
    <url>/2023/07/01/%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h1 id="扩展欧拉定理">扩展欧拉定理</h1>
<p>扩展欧拉定理无需 <em>a</em>,<em>m</em> 互质。</p>
<h2 id="结论">结论</h2>
<p><span class="math display">\[
b\ge\varphi(m)\text{时},a^b\equiv
a^{\left(b\mod\varphi(m)\right)+\varphi(m)}\pmod m
\]</span></p>
<h2 id="证明">证明</h2>
<p>先取 <span class="math inline">\(m\)</span>的一个质因数 <span
class="math inline">\(p\)</span>，令$ m=p^rs<span
class="math inline">\(,\)</span>gcd(p,s)=1$</p>
<p>由欧拉定理得 <span class="math inline">\(p^{\varphi(s)}\equiv1\pmod
s\)</span>由欧拉函数的性质得 <span
class="math inline">\(\varphi(m)=\varphi(s)\times\varphi(p^r)\)</span>，所以
<span class="math inline">\(p^{\varphi(m)}\equiv1\pmod s\)</span> 。</p>
<p>设 <span class="math inline">\(p^{\varphi(m)}=ks+1\)</span>，那么
<span class="math inline">\(p^{\varphi(m)+r}=km+p^r\)</span>，所以 <span
class="math inline">\(p^{\varphi(m)+r}\equiv p^r\pmod m\)</span> 。</p>
<p>当 <span class="math inline">\(b\ge r\)</span> 时，<span
class="math inline">\(p^b\equiv p^{b-r}\times p^r\equiv p^{b-r}\times
p^{\varphi(m)+r}\)</span> <span class="math inline">\(\equiv
p^{b+\varphi(m)}\pmod m\)</span>。</p>
<p>因为 <span
class="math inline">\(r\le\varphi(p^r)\le\varphi(m)\)</span>，所以当
<span class="math inline">\(b\ge 2\varphi(m)\)</span> 时 <span
class="math inline">\(b-\varphi(m)\ge r\)</span>，所以 <span
class="math inline">\(p^b\equiv p^{b-\varphi(m)}\pmod m\)</span>，即
<span class="math inline">\(p^b\equiv p^{(b\mod\varphi(m))+\phi(m)}\pmod
m\)</span>。</p>
<p>将 <span class="math inline">\(a\)</span>
质因数分解后乘起来，就可以得到 <span class="math inline">\(a^b\equiv
a^{(b\mod\varphi(m))+\varphi(m)}\pmod m\)</span>.</p>
<p><strong>需要注意的是，<span
class="math inline">\(b&lt;\varphi(m)\)</span> 时，<span
class="math inline">\(a^b\equiv a^{(b\mod\varphi(m))+\varphi(m)}\pmod
m\)</span>不一定正确。</strong></p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉函数&amp;线性筛</title>
    <url>/2024/11/07/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0&amp;%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
    <content><![CDATA[<h1 id="欧拉函数线性筛">欧拉函数&amp;线性筛</h1>
<h2 id="定义">1. 定义</h2>
<p><span class="math inline">\(\varphi(n)\)</span> 表示所有与<span
class="math inline">\(n\)</span>互质的正整数<span
class="math inline">\(i\)</span>的个数，其中<span
class="math inline">\(i &lt;= n\)</span>.</p>
<h2 id="欧拉定理">2. 欧拉定理</h2>
<p>欧拉定理是指对于任意互质的正整数<span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(n\)</span>，有:</p>
<p><span class="math display">\[
a^{\varphi(n)} \equiv 1\pmod{n}
\]</span></p>
<h2 id="证明">3. 证明</h2>
<p>记小于<span class="math inline">\(n\)</span>且与<span
class="math inline">\(n\)</span>互质的正整数集合<span
class="math inline">\(R\)</span>为：</p>
<p><span class="math display">\[
R = \{ r_1,r_2,r_3,……,r_{\varphi(n)}\}
\]</span></p>
<p>再令集合S为：</p>
<p><span class="math display">\[
S = \{a\times  r_1 \% n,a \times   r_2 \% n,……,a\times
r_{\varphi(n)}\%n\}
\]</span></p>
<p>现在我们先证明<span
class="math inline">\(S\)</span>中的元素两两互不相同。</p>
<p>反证法：假设存在两个整数<span class="math inline">\(i\)</span>
和<span class="math inline">\(j\)</span>（方便起见，令<span
class="math inline">\(i &lt; j\)</span>）使得<span
class="math inline">\(a \times r_i \% n = a \times r_j \%
n\)</span>,则：</p>
<p><span class="math display">\[
a \times r_i \equiv a \times r_j \pmod{n}
\]</span></p>
<p>又因为<span class="math inline">\(a\)</span>与<span
class="math inline">\(n\)</span>互质，所以<span
class="math inline">\(r_i = r_j\)</span>,而<span class="math inline">\(i
&lt; j\)</span>，即 <span class="math inline">\(r_i \neq
r_j\)</span>，矛盾，所以<span
class="math inline">\(S\)</span>中元素两两互不相同。</p>
<p>又因为<span class="math inline">\(a\)</span> 与 <span
class="math inline">\(n\)</span>互质，<span
class="math inline">\(r_i\)</span>与 n互质，所以易得<span
class="math inline">\(a * r_i \% n\)</span>与 <span
class="math inline">\(n\)</span> 互质，即<span
class="math inline">\(S\)</span>中的元素都与 <span
class="math inline">\(n\)</span> 互质。</p>
<p>所以可以得到 <span class="math inline">\(R = S\)</span>.</p>
<p>所以 ：</p>
<p><span class="math display">\[
\prod_{i = 1}^{\varphi(n)}{r_i} = \prod_{i = 1}^{\varphi(n)}{a \times
r_i\%n}
\]</span></p>
<p><span class="math display">\[
\prod_{i = 1}^{\varphi(n)}{r_i} \equiv \prod_{i = 1}^{\varphi(n)}{r_i
\times a} \pmod{n}
\]</span></p>
<p><span class="math display">\[
\prod_{i = 1}^{\varphi(n)}{r_i} \equiv a^{\varphi(n)}  \times \prod_{i =
1}^{\varphi(n)}{r_i}  \pmod{n}
\]</span></p>
<p>又因为$_{i = 1}^{(n)}{r_i} $ 与 n 互质，</p>
<p>所以： <span class="math display">\[
a^{\varphi(n)} \equiv 1 \pmod{n}
\]</span></p>
<h2 id="线性筛">4.线性筛</h2>
<p>先上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> prime[maxn],px,l,r,n;</span><br><span class="line"><span class="type">bool</span> b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!b[i]) </span><br><span class="line">			prime[++px] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=px &amp;&amp; i * prime[j] &lt;= n; j++) &#123;</span><br><span class="line">			b[prime[j] * i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=px; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,prime[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>算法的正确性证明中，其实我们要证明的就是两点：</p>
<ul>
<li>每一个合数都会被筛掉。</li>
<li>每一个合数只能被筛一遍（以保证时间复杂度<span
class="math inline">\(O(n)\)</span>)</li>
</ul>
<p>对于第一点，证明如下：</p>
<p>设这个合数为<span class="math inline">\(v\)</span>,则 <span
class="math inline">\(v = p_1 p_2   ……
p_k(p_i&lt;=p_{i+1})\)</span>，<span class="math inline">\(p\)</span> 为
<span class="math inline">\(v\)</span>的质因数。</p>
<p>可以发现，当<span class="math inline">\(i = p_2 \cdot p_3 \cdot  ……
\cdot p_k\)</span>, <span class="math inline">\(prime[j] =
p_1\)</span>时，<span class="math inline">\(i\)</span>与所有小于<span
class="math inline">\(p_1\)</span>的质数互质，所以中途不会被break掉，所以此时<span
class="math inline">\(v\)</span>可以被筛掉。</p>
<p>对于第二点，证明如下：</p>
<p>在第一点中，我们是证明了v会在<span class="math inline">\(i = p_2
\times p_3 \times …… \times p_k\)</span>, <span
class="math inline">\(prime[j] =
p_1\)</span>时被筛掉，那么现在就是要证明除了这种情况外，v不会被筛掉。</p>
<p>设当<span class="math inline">\(i = p_1 \times p_2 \times ... \times
p_{m - 1} \times  p_{m + 1} \times ... \times p_k\)</span> <span
class="math inline">\((p_i &lt;= p_{i + 1})\)</span> 时</p>
<p><span class="math inline">\(prime[j] = p_m(p_m \neq p_1)\)</span>时 v
被筛掉.</p>
<p>可以发现 <span class="math inline">\(p_1 | i\)</span>,所以当<span
class="math inline">\(prime[j] =
p_1\)</span>时就会被break掉，所以v不会在此时被筛掉。</p>
<p>由此，我们可以证明，算法的正确性和时间复杂度的正确性。</p>
<h2 id="求欧拉函数">5.求欧拉函数</h2>
<p>首先，欧拉函数是一个积性函数。</p>
<p>积性函数的定义是：函数<span
class="math inline">\(f(x)\)</span>,若满足<span
class="math inline">\(f(m \times n) = f(m) \times f(n) (gcd(n,m) =
1)\)</span>,那么<span
class="math inline">\(f(x)\)</span>就是一个积性函数。</p>
<p>欧拉函数是一个积性函数。</p>
<p>设$n = p_1^{m_1} p_2^{m_2} p_3^{m_3} …… p_k^{m_k} <span
class="math inline">\(,\)</span>p_iP$，则有：</p>
<p><span class="math display">\[
\varphi(n) = \varphi(p_1^{m_1}) \times \varphi(p_2^{m_2}) \times ……
\times \varphi(p_k^{m_k})
\]</span></p>
<p>对于<span class="math inline">\(\varphi(p^k),p_i \in
P\)</span>，易得<span class="math inline">\(\varphi(p^k) = p^k - p^{k -
1} = p^k \times (1 - \frac{1}{p})\)</span></p>
<p>所以有：</p>
<p><span class="math display">\[
\varphi(n) = p_1^{m_1} \times p_2^{m_2} \times p_3^{m_3} \times ……
\times p_k^{m_k} \times (1 - \frac{1}{p_1}) \times (1 - \frac{1}{p_2})
\times …… \times (1 - \frac{1}{p_k})  \\= n \times (1 - \frac{1}{p1})
\times (1 - \frac{1}{p2}) \times …… \times (1 - \frac{1}{p_k}))
\]</span></p>
<p>特别的，当<span class="math inline">\(n \in P\)</span>时，<span
class="math inline">\(\varphi(n) = n - 1\)</span>.</p>
<p>理解了上面这些，可以上代码了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,phi[maxn],prime[maxn],px;</span><br><span class="line"><span class="type">bool</span> b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!b[i]) &#123;</span><br><span class="line">			prime[++px] = i;</span><br><span class="line">			phi[i] = i - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=px &amp;&amp; prime[j] * i &lt;= n; j++) &#123;</span><br><span class="line">			b[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">				phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			phi[i * prime[j]] = phi[i] * phi[prime[j]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,phi[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个代码是由线性筛变过来的。</p>
<p>当<span class="math inline">\(i \in P\)</span>时，毫无疑问<span
class="math inline">\(\varphi(i) = i - 1\)</span>.</p>
<p>当<span class="math inline">\(i \notin
P\)</span>时，分以下两种情况讨论：</p>
<ul>
<li>若<span class="math inline">\(i \% prime[j] \neq
0\)</span>，因为<span class="math inline">\(prime[j] \in
P\)</span>,所以<span class="math inline">\(gcd(i,prime[j])) =
1\)</span>。因此根据积性函数的定义，有：</li>
</ul>
<p><span class="math display">\[
\varphi(i \times prime[j]) = \varphi(i) \times \varphi(prime[j])
\]</span></p>
<ul>
<li>若<span class="math inline">\(i \% prime[j] = 0\)</span>，因为<span
class="math inline">\(prime[j] \in P\)</span>,所以<span
class="math inline">\(prime[j]\)</span>必定为 i 的一个质因数，所以<span
class="math inline">\(prime[j]\)</span>必定是<span
class="math inline">\(p_1,p_2,p_3,……,p_k\)</span>中的一个，因此得到：
<span class="math display">\[
  \varphi(i \times prime[j]) = i \times prime[j] \times (1 -
\frac{1}{p1}) \times (1 - \frac{1}{p2}) \times …… \times (1 -
\frac{1}{p_k})) = \varphi(i) \times prime[j]
  \]</span></li>
</ul>
<p>最后和线性筛一样，可以证明欧拉函数求法时间复杂度也是线性的。</p>
<p>特别的，<span class="math inline">\(\varphi(1) = 1\)</span>.</p>
<h2 id="一些神奇定理">6.一些神奇定理</h2>
<ul>
<li><p><span class="math inline">\(\sum_{d|n}\varphi(d) =
n\)</span></p></li>
<li><p><span class="math inline">\(\forall n &gt;
1,1-n\)</span>中与n互质的数的和为<span class="math inline">\(n \times
\varphi(n) / 2\)</span></p></li>
<li><p><span class="math inline">\(若gcd(a,n) = 1\)</span> $ 正整数b$
<span class="math inline">\(a^b \equiv a^{b \ mod
\  \varphi(n)}(mod\  n)\)</span></p></li>
<li><p>若<span class="math inline">\(a\)</span>,<span
class="math inline">\(n\)</span>互质，则满足<span
class="math inline">\(a^x \equiv 1 (mod \ n)\)</span>的最小正整数<span
class="math inline">\(x_0\)</span>是<span
class="math inline">\(\varphi(n)\)</span>的约数。</p></li>
</ul>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>《算法竞赛进阶指南》笔记</title>
    <url>/2023/07/04/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="算法竞赛进阶指南笔记">《算法竞赛进阶指南》笔记</h1>
<h2 id="x00基本算法">0x00基本算法</h2>
<h3 id="x01位运算">0X01位运算</h3>
<ul>
<li>计算机读入原码A，然后将读入的原码转为补码B，接下来对补码进行运算得到运算后的补码C，最后将补码C转换为原码D输出。</li>
<li>要注意%1这种特殊情况。任何数%1都是0。</li>
<li>回忆这道题：<span class="math inline">\(1 \le a \le 10^{18},1 \le b
\le 10^{18}\)</span>,<span class="math inline">\(1 \le p \le 10 ^
{18}\)</span>,输出<span class="math inline">\(a \times
b\)</span>。这道题有两种解法。</li>
<li>回忆：起床困难综合症</li>
<li>写状压动规时，如果遇到不知道按照什么顺序遍历状态的情况，可以直接<code>for (int i=0; i&lt;(1 &lt;&lt; n); i++)</code>来遍历，可以保证求解后继状态时前驱状态已经求解完毕。</li>
<li>注意如果要读入一个<span class="math inline">\(n\)</span>行<span
class="math inline">\(m\)</span>列的字符矩阵，要用<span
class="math inline">\(n\)</span>个字符数组来读，切忌不可用单个字符读入，在linux系统下会出错。</li>
<li><code>x &gt;&gt; 1</code>会将<code>x</code>向下取整，而<code>x / 2</code>会将<code>x</code>向零取整。</li>
</ul>
<h3 id="x02递归与递推">0x02递归与递推</h3>
<ul>
<li>数组要开大开大开大！！！</li>
<li>求一个数的约数和，可以先将其质因数分解。如要求<span
class="math inline">\(n\)</span>的约束和，质因数分解得到<span
class="math inline">\(n = \prod_{i = 1}^np_i ^{s_i}\)</span>，然后<span
class="math inline">\(n\)</span>的约数个数为<span
class="math inline">\(\prod_{i = 1}^n(s_i + 1)\)</span>,约数和为<span
class="math inline">\(\prod_{i = 1}^n \sum_{j =
0}^{s_i}p_i^j\)</span>。</li>
<li>将一个数分解质因数的时候要注意处理$ &gt;
$的质因数。这类质因数如果有就只有1个，但千万要注意！！！！</li>
</ul>
<h3 id="x03前缀和与差分">0x03前缀和与差分</h3>
<ul>
<li>回忆一下<a
href="http://noi-test.zzstep.com/contest/0x00「基本算法」例题/0304%20IncDec%20Sequence">这道题</a>。</li>
<li>要用<code>abs函数</code>的话还是引用<code>cmath</code>库，不要手写。手写<code>abs函数</code>可能会引发<code>ambiguous</code>编译错误。</li>
<li>回忆一下<a
href="https://www.acwing.com/problem/content/103/">这道题</a>。</li>
</ul>
<h3 id="x04二分">0x04二分</h3>
<ul>
<li><p>初赛的考点。二分的写法要么是<code>mid = (l + r) &gt;&gt; 1,l = mid + 1,r = mid</code>，要么是<code>mid = (l + r + 1) &gt;&gt; 1,l = mid,r = mid - 1</code>。</p></li>
<li><p>实数域上的二分，通常eps设为<span class="math inline">\(10^{-(k +
2)}\)</span>,其中<span
class="math inline">\(k\)</span>是要保留的小数位数。
有时候精度不易确定，就干脆固定循环次数，可以这样写：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">   	<span class="type">double</span> mid = (l + r) / <span class="number">2</span>；</span><br><span class="line">    	<span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">       	l = mid; <span class="keyword">else</span></span><br><span class="line">           r = mid;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>回忆一下<a
href="https://www.acwing.com/problem/content/104/">这道题</a>。</p></li>
<li><p>如果你的答案是一个实数，而题目要求你向下取整，你就要小心，不能直接用<code>floor()</code>,因为你的浮点数会有误差，比如<code>1.5</code>会变成<code>1.499999999999999999999075</code>。所以如果题目要求你保留4位，你就直接将整个计算过程用整数来实现，同时将整数扩大1000倍来保证精度。</p></li>
<li><p>用这种写法 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">   	mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">       	l = mid + <span class="number">1</span>; <span class="keyword">else</span></span><br><span class="line">           r = mid - <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure> <span
class="math inline">\(\hspace{1cm}\)</span>
要注意<code>while</code>循环外面最后还要<code>check</code>一下<code>l</code>，因为最后<code>l</code>也是一个可能的答案，但是你的<code>while</code>条件是<code>l &lt; r</code>,当<code>l = r</code>时会扼杀这种可能性。</p></li>
<li><p><a
href="https://blog.csdn.net/hzk_cpp/article/details/94895213">证明：对于任意有向完全图存在Hamilton路径</a></p></li>
<li><p>三分求单峰函数最值时，对于区间<span
class="math inline">\([l,r]\)</span>,三分得到两个点<span
class="math inline">\(m1,m2\)</span>。则接下来枚举的是** “较差”
**的那个点与离这个点较远的一个端点（l或r)构成的区间。</p></li>
</ul>
<h3 id="x05排序">0x05排序</h3>
<ul>
<li><p>lower_bound用法：<code>int p = lower_bound(a + 1,a + n + 1,x) - a</code>。注意返回的是第一个<strong>小于等于</strong><code>x</code>的数的下标。</p></li>
<li><p><code>unique</code>用法:<code>int p = unique(a + 1,a + n + 1) - a - 1</code>。</p></li>
<li><p>可以用一个大根堆和一个小根堆来维护一个不断加数的序列的第<span
class="math inline">\(k\)</span>大数。比如<a
href="https://www.acwing.com/problem/content/108/">这道题</a>和<a
href="https://www.luogu.com.cn/problem/P1801">这道题</a>.</p></li>
<li><p>回忆<a
href="https://www.acwing.com/problem/content/107/">这道题</a>。</p></li>
<li><p>遇到要开<code>long long</code>的时候还是<code>define int long long</code>比较保险。</p></li>
<li><p>两个<strong>相邻的数</strong>之间的交换<strong>最多</strong>只会增加或减少<strong>一个逆序对</strong>，也有可能逆序对个数没有变化。<a
href="https://www.acwing.com/problem/content/109/">Problem for
this</a>.</p></li>
<li><p>回忆一下<a
href="https://www.acwing.com/solution/content/1294/">这道题</a>。这题的结论是：</p>
<ul>
<li>对于奇数码问题，两个局面可互相到达当且仅当将两个局面写成一维序列后两个序列的逆序对个数奇偶性相同。</li>
<li>对于偶数码问题，两个局面可互相到达当且仅当将两个局面写成一维序列后两个序列的“逆序对数之差”和“两个局面下空格所在的行数之差”奇偶性相同。</li>
</ul>
<p>该结论的充分性尚未证明。</p></li>
<li><p>一个启示：<strong>一些移动问题都可以弄成一维来看，环的话可以断成链来考虑</strong>。</p></li>
<li><p>运用奇偶性时的技巧：如果操作值是累加/减的，那么使正确的操作值为偶数，因为偶数
<span class="math inline">\(\pm\)</span> 偶数 =
偶数。如果操作值是累乘,则使正确的操作值为奇数，那么这样可以保证只要一个错误的操作出现，最后的结果可以显示为错误。</p></li>
</ul>
<h3 id="x06倍增">0x06倍增</h3>
<ul>
<li>回忆<a
href="https://www.acwing.com/problem/content/111/">这道题</a>。</li>
<li>回忆<a
href="https://www.luogu.com.cn/problem/P1613">这道题</a>。</li>
</ul>
<h3 id="x07贪心">0x07贪心</h3>
<ul>
<li><p>回忆<a href="https://www.acwing.com/problem/content/112/">problem
1</a>和<a href="https://www.acwing.com/problem/content/113/">problem
2</a>和<a href="https://www.acwing.com/problem/content/114/">problem
3</a>。</p></li>
<li><p><a href="https://www.acwing.com/problem/content/116/">problem
4</a> <a
href="https://www.acwing.com/problem/content/117/">problem5</a>.</p></li>
<li><p><code>vector</code>的<code>size()</code>返回值是一个<code>unsigned int</code>,所以对其<code>-1</code>或减去一个数时要慎重。</p></li>
</ul>
<h3 id="x00习题集">0x00习题集</h3>
<ul>
<li><p>开<code>long long</code>!!!!!!</p></li>
<li><p><a href="https://www.acwing.com/problem/content/122/">problem
1</a></p></li>
<li><p><a href="https://www.acwing.com/problem/content/123/">problem
2</a></p></li>
<li><p><a href="https://www.acwing.com/problem/content/124/">problem
3</a></p></li>
<li><p><a href="https://www.acwing.com/problem/content/127/">problem
4</a> (这道题虽然你做出来了，但是还是要看一下的！）</p></li>
<li><p><a href="https://www.acwing.com/problem/content/129/">problem
5</a>(注意取值范围！）</p></li>
</ul>
<h2 id="x10基本数据结构">0x10基本数据结构</h2>
<h3 id="x11栈">0x11栈</h3>
<ul>
<li><p><a href="https://www.acwing.com/problem/content/130/">problem
1</a>回忆这道题以及它的思想！</p></li>
<li><p>后缀表达式计算方式：</p>
<p>遇到数就入栈，遇到符号就取出栈顶两数运算，并将运算结果重新入栈。</p></li>
<li><p>中缀表达式转后缀表达式：</p>
<p>遇到数就输出。</p>
<p>遇到左括号就入栈。</p>
<p>遇到右括号就一直弹出并输出栈中符号，直到遇到左括号。</p>
<p>遇到运算符，若栈顶运算符等级不低于新符号，则一直去除栈顶并输出，最后把新符号入栈。</p>
<p>最后依次取出并输出栈中的剩余符号。</p></li>
</ul>
<h3 id="x12-队列">0x12 队列</h3>
<ul>
<li><a href="https://www.acwing.com/problem/content/135/">problem
1</a></li>
<li><a href="https://www.acwing.com/problem/content/136/">problem
2</a></li>
</ul>
<h3 id="x13-链表">0x13 链表</h3>
<ul>
<li><a href="https://www.acwing.com/problem/content/138/">problem
1</a></li>
</ul>
<h3 id="x14-hash">0x14 Hash</h3>
<ul>
<li><a href="https://www.acwing.com/problem/content/141/">problem
1</a></li>
<li><a href="https://www.acwing.com/problem/content/142/">problem
2</a></li>
</ul>
<h3 id="x15-字符串">0x15 字符串</h3>
<ul>
<li>p75 最小表示法</li>
</ul>
<h3 id="x16-trie">0x16 Trie</h3>
<h3 id="x17-二叉堆">0x17 二叉堆</h3>
<ul>
<li><a href="https://www.acwing.com/problem/content/147/">problem
1</a></li>
<li><a href="https://www.acwing.com/problem/content/148/">problem
2</a></li>
<li><a href="https://www.acwing.com/problem/content/149/">problem
3</a></li>
</ul>
<h3 id="x18-huffman-树">0x18 Huffman 树</h3>
<ul>
<li><a href="https://www.acwing.com/problem/content/151/">problem
1</a></li>
</ul>
<h3 id="习题集">习题集</h3>
<ul>
<li><a href="https://www.acwing.com/problem/content/152/">problem
1</a></li>
<li><a href="https://www.acwing.com/problem/content/154/">problem
2</a></li>
<li><a href="https://www.acwing.com/problem/content/155/">problem
3</a></li>
<li><a href="https://www.acwing.com/problem/content/159/">problem
4</a></li>
<li>算了都看一遍吧。</li>
</ul>
<p>​<br />
​</p>
<h2 id="x30数学知识">0x30数学知识</h2>
<h3 id="x31-质数">0x31 质数</h3>
<ul>
<li><a
href="https://www.acwing.com/problem/content/199/">阶乘分解</a></li>
</ul>
<h3 id="x32约数">0x32约数</h3>
<ul>
<li><p><a
href="https://www.acwing.com/problem/content/200/">problem1</a></p></li>
<li><p><a
href="https://www.acwing.com/problem/content/201/">神仙题</a></p></li>
<li><p><a
href="https://www.acwing.com/problem/content/202/">problem2</a></p></li>
<li><p>欧拉函数：详见《欧拉函数学习笔记》</p></li>
<li><p><a
href="https://www.acwing.com/problem/content/description/204/">problem
3</a></p></li>
<li><p><code>(a &amp; b) ^ (a &amp; c) = a &amp; (b ^ c)</code>。</p></li>
</ul>
<h2 id="x40-数据结构">0x40 数据结构</h2>
<ul>
<li>线段树你的写法要开<strong>8倍</strong>空间！！！</li>
<li>留坑：cdq分治，莫队，可持久化数据结构</li>
</ul>
<h2 id="x50动态规划">0x50动态规划</h2>
<ul>
<li>注意：最大值和最小值一定要初始化，不能任其为0，否则会出问题。</li>
<li>建图的first，last，nxt数组在多组数据时都要初始化！！！！</li>
</ul>
<h2 id="x60图论">0x60图论</h2>
<ul>
<li>注意：hash是关键字，不要用它作为变量名或函数名！！！</li>
<li><a
href="https://www.acwing.com/problem/content/description/352/">很巧妙的一道题！</a></li>
</ul>
<h2 id="tips">Tips</h2>
<ul>
<li>遇到和式一定要分开来考虑，就是说<span class="math inline">\(\sum_{i
= l}^ r(A + B) = \sum_{i = l}^rA + \sum_{i =
l}^rB\)</span>,可以保证，分开来考虑一定更简单。</li>
</ul>
<h2 id="xff-血的教训">0xFF 血的教训</h2>
<ul>
<li><p>对<span
class="math inline">\(n\)</span>进行质因数分解时，先找到在1到根号n之间的所有质数，然后，千万不要忘记，<strong>n还可能有一个大于根号n的质因数，这个质因数可以是n，也可以不是n！</strong></p></li>
<li><p>入队时不要写成<code>q[--tail] = q[tail + 1];</code>,写成这样:<code>tail--;             q[tail] = q[tail + 1];</code></p></li>
<li><p>后缀数组初始化要记得把sa,t1,t2都清空！还有记得c数组的大小要开到字符串长度！</p></li>
<li><p>后缀数组在build—height的时候要注意i的循环要从1开始循环，然后判断rnk[i]
== 1时跳过，i循环不能直接从2开始！</p></li>
</ul>
<p>正确写法见后缀数组那篇文章</p>
<ul>
<li><p><span class="math inline">\(a^b\)</span>对m取余的结果等于<span
class="math inline">\(a^{b \%
\varphi(m)}\)</span>对<strong>m</strong>取余的结果，注意加粗处是m，不是<span
class="math inline">\(\varphi(m)\)</span>!!</p></li>
<li><p>树状数组query时要记得return ans！！！ <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">5</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">		i = i;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> j = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">5</span>; j&gt;<span class="number">5</span>; ++j)</span><br><span class="line">		j = j;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;j = %d\n&quot;</span>,j);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>请说出输出的结果</p>
<ul>
<li>C++ 右移是算术右移，空出来的位用符号位补</li>
</ul>
]]></content>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>同余&amp;中国剩余定理&amp;中国剩余定理の扩展</title>
    <url>/2023/07/05/%E5%90%8C%E4%BD%99%E5%92%8C%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="同余">同余</h2>
<h3 id="线性同余方程">1.线性同余方程</h3>
<p>给定整数<span class="math inline">\(a,b,m\)</span>求一个整数<span
class="math inline">\(x\)</span>满足<span class="math inline">\(ax
\equiv b \pmod m\)</span>，或给出无解。</p>
<p>设<span class="math inline">\(a \times x  = b + my\)</span>，则<span
class="math inline">\(ax + my = b\)</span>，有解的充要条件是<span
class="math inline">\(gcd(a,m)|b\)</span>.</p>
<p>接下来只要用exgcd求出一个解，然后就可以求通解了。</p>
<h3 id="中国剩余定理">2.中国剩余定理</h3>
<p>设<span
class="math inline">\(m_1,m_2,m_3,……,m_n\)</span>是两两互质的整数，对于任意的<span
class="math inline">\(n\)</span>个整数<span
class="math inline">\(a_1,a_2,……,a_n\)</span>，关于<span
class="math inline">\(x\)</span>的方程组 <span class="math display">\[
\begin{cases} x \equiv  a_1 \pmod {m_1}\\x \equiv a_2 \pmod {m_2}\\……\\x
\equiv a_n \pmod{m_n}\end{cases}
\]</span> 有整数解。</p>
<p>证明：</p>
<p>设<span class="math inline">\(m =  \prod_{i = 1}^nm_i,M_i = m /
m_i\)</span>，<span
class="math inline">\(t_i\)</span>是线性同余方程<span
class="math inline">\(M_it_i \equiv 1 \pmod{m_i}\)</span>的一个解。</p>
<p>则<span class="math inline">\(x_0 = \sum_{i = 1}^n
a_iM_it_i\)</span>是一个解</p>
<p>因为<span class="math inline">\(M_i\)</span>是除了<span
class="math inline">\(m_i\)</span>以外所有数的倍数，所以<span
class="math inline">\(\forall k \neq i,a_iM_it_i \equiv 0
\pmod{m_k}\)</span>。而因为<span class="math inline">\(M_it_i \equiv  1
\pmod {m_i}\)</span>，所以 $a_iM_it_i a_i $。</p>
<p>这是一个特解。通解为<span class="math inline">\(x = x_0 + km(k \in
Z)\)</span>。</p>
<ul>
<li><p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m[<span class="number">30</span>],a[<span class="number">30</span>],M = <span class="number">1</span>,v[<span class="number">30</span>],t[<span class="number">30</span>],V1,V2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">		x = <span class="number">1</span>;</span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="type">int</span> d = <span class="built_in">exgcd</span>(b,a % b,x,y);</span><br><span class="line">	<span class="type">int</span> z = x;</span><br><span class="line">	x = y,y = z - (a / b) * y;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m[i],&amp;a[i]);</span><br><span class="line">		M = M * m[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		v[i] = M / m[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x0,y0;</span><br><span class="line">		<span class="type">int</span> gcd = <span class="built_in">exgcd</span>(v[i],m[i],x0,y0);</span><br><span class="line">		x0 %= m[i];</span><br><span class="line">		<span class="keyword">if</span> (x0 &lt;= <span class="number">0</span>)</span><br><span class="line">			x0 += m[i];</span><br><span class="line">		t[i] = x0; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		sum += a[i] * v[i] * t[i];</span><br><span class="line">	sum %= M;</span><br><span class="line">	<span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">		sum += M;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="中国剩余定理的扩展版本">3.中国剩余定理的扩展版本</h3>
<p>上面的方法要求<span
class="math inline">\(m_1,m_2,……,m_n\)</span>两两互质。现在给出一种对<span
class="math inline">\(m_i\)</span>没有要求的算法。</p>
<p>数学归纳法：假设前<span class="math inline">\(k -
1\)</span>个方程已经求出了一个解<span
class="math inline">\(x\)</span>。记<span class="math inline">\(m =
lcm(m_1,m_2,……,m_{k - 1})\)</span>，则<span class="math inline">\(x + i
\times m (i \in Z)\)</span>是前<span class="math inline">\(k -
1\)</span>个方程的通解。</p>
<p>考虑第<span class="math inline">\(k\)</span>个方程，求一个<span
class="math inline">\(t\)</span>，使得<span class="math inline">\(x + t
\times m \equiv a_k \pmod {m_k}\)</span>。将这个方程变换一下，得到<span
class="math inline">\(m \times t \equiv a_{k} - x \pmod
{m_k}\)</span>,求<span class="math inline">\(t\)</span>. <span
class="math display">\[
m \times t + m_{k} \times p = a_{k} - x
\]</span></p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>一个经典期望问题的分治想法</title>
    <url>/2023/07/08/%E4%B8%80%E4%B8%AA%E6%9C%9F%E6%9C%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li><p>问题： 在一条长度为1的线段上随机撒两个点<span
class="math inline">\(A\)</span>,<span class="math inline">\(B\)</span>,
求线段<span class="math inline">\(AB\)</span>的期望长度</p></li>
<li><p>解：设在一条长度为1的线段上随机撒的两个点<span
class="math inline">\(A\)</span>,<span
class="math inline">\(B\)</span>所截得的线段期望长度为<span
class="math inline">\(x\)</span></p>
<p>​ 然后将这条长度为1的线段均分成左右两段：</p>
<ul>
<li><p>若<span
class="math inline">\(A,B\)</span>两点都在左半部分，那么发生这种情况的概率为0.25，期望长度为<span
class="math inline">\(\frac 12 x\)</span></p></li>
<li><p>若<span
class="math inline">\(A,B\)</span>两点都在右半部分，那么发生这种情况的概率为0.25，期望长度为<span
class="math inline">\(\frac 12 x\)</span></p></li>
<li><p>若<span
class="math inline">\(A,B\)</span>两点横跨线段中点，那么发生这种情况的概率为0.5</p>
<p>​ 设线段中点为<span class="math inline">\(M\)</span>，那么<span
class="math inline">\(E(|AB|) = E(|AM|) + E(|MB|)\)</span> <span
class="math inline">\(= 0.25 + 0.25 = 0.5\)</span></p>
<p>​ 所以这种情况下期望长度为0.5</p></li>
</ul>
<p>所以，根据期望的定义，我们可以得到$x = 0.25 x + 0.25 $ <span
class="math inline">\(\frac 12 x + 0.5\times 0.5\)</span></p>
<p>解得：<span class="math inline">\(x = \frac 13\)</span></p></li>
</ul>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>一个不等式</title>
    <url>/2023/07/07/%E4%B8%80%E4%B8%AA%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
    <content><![CDATA[<p>对于任意正整数<span class="math inline">\(m,n\)</span>，有： <span
class="math display">\[
\sum_{i=1}^n\frac{ {a_i}^{m+1} }{ {b_i}^m}\ge\frac{(\sum_{i=1}^na_i)^{m
+ 1} }{(\sum_{i = 1}^n {b_i})^m}
\]</span></p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>臆想</title>
    <url>/2023/07/11/%E8%87%86%E6%83%B3/</url>
    <content><![CDATA[<h1 id="臆想">臆想</h1>
<p>很久很久以前，在某个地方，突然出现了一所监狱。</p>
<p>这所监狱很大，很大，很大，没有人知道它到底有多大。这所监狱很深，很深，很深，没有人知道它到底有多深。最奇怪的是，这所监狱是凭空产生的，没有人知道它到底是怎么来的。</p>
<p>又过了很久很久，一件更奇怪的事情开始发生了：每隔一段时间，就会有一批犯人被送进这所监狱。你若问他：”你原来来自哪里？你犯了什么罪？“，他只会回答：”我不知道。“</p>
<p>这所监狱里也有许多怪物，能随意地穿越墙壁，过道，房间，它们的日常娱乐即为折磨犯人。红色的怪物喜欢粗暴地折断犯人的躯干或四肢，蓝色的怪物喜欢掏出犯人的脏器，在上面动一点小手脚，然后再把它塞回去，让犯人慢慢死去。还有一种紫色的怪物，它最喜欢干的事情是将一些食物抛在犯人们之间，接着它就在旁边旁观犯人们为了争抢食物而相互厮杀。</p>
<p>这所监狱区别于其他监狱最大的特点在于它时刻允许犯人们越狱。在每个犯人的房间里面，都有一个传送门。只要几分钟时间，犯人就可以通过这道传送门越狱。面对监狱里那些恐怖怪物的折磨，一开始，绝大多数的犯人都选择了越狱，因此，在相当长的一段时间里，这所监狱里空无一人。</p>
<p>你也许会问我，这批越狱的犯人后来去了哪里？过得怎样？我只能回答你，我不知道，因为我从未穿越过传送门，也从来没有见到有犯人从传送门中回来。这个监狱里的犯人曾对监狱外的世界做过种种猜测，但没有人知道真相究竟是如何。</p>
<p>可是，有一天，一批特殊的犯人被送了进来。这批犯人和以前送来的犯人没有任何区别，除了一点：他们的身体构造出现了一些变化，使得他们在穿越传送门越狱的那几分钟里会莫名其妙地感受到巨大的痛苦。就是因为这个变化，这批犯人中的绝大多数都没有选择越狱。就这样，原本空无一物的监狱渐渐被这类犯人充满。</p>
<p>对于犯人们，时间艰涩地流过。他们无时无刻不在期待着穿过传送门，可是只有少数勇士做到了，大多数只能在黑暗中祈祷自己不是怪物的下一个目标。</p>
<p>由于这个特殊的机制，这个监狱已经存在了好久好久，而且也可以预见它还可以继续存在很久很久。但是，经过很久很久之后，监狱的墙会和门融合，壁会和杆融合，任何地方一切的一切会和任何地方的一切的一切融合，直到分不清彼此。据说，到那时候，上帝将会摧毁这座监狱，释放其中所有的犯人。</p>
<p>期待这一天早日到来吧</p>
<p>以上是一名犯人写下的一点文字。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>一些文字</title>
    <url>/2023/07/09/%E4%B8%80%E4%BA%9B%E6%96%87%E5%AD%97/</url>
    <content><![CDATA[<p>1938年11月，一间禅房中，两人以跪姿相对而坐。右首脊背笔挺，手摇折扇的是本因坊世家第二十一代”不败名人“，本因坊秀哉九段。虽仍为一头黑发，却早已年过花甲。秀哉自知年岁已大，且疾病缠身，大约大限之期不远矣，遂有意下一盘隐退棋。这盘棋的对手是从数百名职业棋手中脱颖而出青年棋手，木谷实七段。比赛于6月24日开始，木谷实执黑，秀哉执白。</p>
<p>2小时前，秀哉从容落下白96手，蛤基石与榧木棋盘间发出碰撞声。接下来2小时，两人好似入定，禅院中空气似乎也已凝固。这样的状态已持续4个月，并且还会再延续2个月。6个月的时间中，禅院外是隆隆的火炮爆裂声，而禅院的灯光下，只有清脆的落子声，其余便是时间积淀成的寂静。</p>
<p><img src="https://s1.ax1x.com/2020/08/16/dEWVG4.png" /></p>
<p>1992年，大洋彼岸的英国牛津，37岁的数学教授Andrew
Wiles正坐在自己的阁楼中。5年前，随着一系列的学术进展，已经尘封358年的费马大定理似乎有了研究的方向。Wiles
在那时感觉到证明费马大定理的时间已经来到，遂推掉了其他所有学术研讨会，钻进自己的阁楼中，对大定理发起冲击。5年来，他每天只做一件事：证明费马大定理。除了睡觉和吃饭，他将自己所有的时间都埋入阁楼里的草稿纸中。</p>
<p>1995年，Andrew
Wiles终于成功证明了费马大定理，8年阁楼中的研究岁月换来的是一份写满138页A4纸的证明。2005年，Wiles来到北大交流时，北大数学系院长张继平感慨到：”如今还有多少人能静下心来，花8年时间认认真真只做一件事情呢？“</p>
<p>的确，现在这样的人已经很鲜见了。一盘围棋赛的时间从半年变为区区5小时，一项研究的平均时间也从8年变为如今的一个月甚至更少。随着社会的发展，我们要做的事情越来越多，而做每件事情的时间却越来越少，对应的，生活也变得越来越琐碎。时代的快车拽着我们一路飞奔，时间被划分成越来越小的片段。</p>
<p>或许，我们真的应该慢下来，用一生时间做一件事情，这样的生活或许难以实现，但真的很浪漫。</p>
<p>​</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>2023.6.20</title>
    <url>/2023/07/10/%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</url>
    <content><![CDATA[<p>想法来自一个同学的说说，稍微做了一点改动：</p>
<p>我们总是觉得年纪越大时间过得越快，其实不然。童年时觉得时间过得很慢，是因为我们在彼时将精力全部投入在观察现实世界中。而随着年龄的增长，我们会把越来越多的时间用来回忆过去和遥想未来。关照现在的时间变少了，就会感到时间变得飞快，仿佛俯仰之间白驹已过隙。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>西点</title>
    <url>/2023/07/06/%E8%A5%BF%E7%82%B9/</url>
    <content><![CDATA[<h1 id="西点">西点</h1>
<h2 id="卷">1.卷</h2>
<h4 id="原料">原料：</h4>
<ul>
<li>低筋粉250g</li>
<li>鸡蛋10个</li>
<li>色拉油150g</li>
<li>水200mL</li>
<li>5%糖的奶油（用稀奶油和糖制得）</li>
<li>250g糖</li>
</ul>
<h4 id="步骤">步骤：</h4>
<p>1.蛋清蛋黄分离。</p>
<p>2.蛋清 + 200g糖打发至“软尖锋”。</p>
<p>3.200mL水 + 50g糖 + 150g油搅拌至糖化掉。</p>
<p>4.往步骤3中的混合物中加面粉搅匀。</p>
<p>5.往步骤4中的混合物中加蛋黄搅匀。</p>
<p>6.将步骤5所得混合物和步骤2所得混合物一起搅匀（注意这里要用<strong>刮板</strong>搅拌，用翻拌和切拌的方法，减少气泡逃逸）。</p>
<p>7.将步骤6所得物在烤盘里铺平，送入烤箱烤。</p>
<p>8.将稀奶油和5%糖打法，然后将奶油均匀涂抹在烤好的蛋糕上，然后将蛋糕卷起来即可。</p>
<h2 id="泡芙">2.泡芙</h2>
<h4 id="原料-1">原料：</h4>
<ul>
<li>黄油215g</li>
<li>鸡蛋3个</li>
<li>水160mL</li>
<li>低筋粉205g</li>
<li>糖粉96g</li>
<li>杏仁粉 30g</li>
</ul>
<h4 id="步骤-1">步骤：</h4>
<p>1.将135g黄油，96g糖粉，30g杏仁粉，低筋粉105g搅匀，将混合物弄成棒状，放入冰箱冷冻一晚。</p>
<p>2.将黄油和水加热至沸（用蛋抽搅拌）</p>
<p>3.2中产物加热至沸后，迅速往其中导入100g低筋面粉，用蛋抽搅拌至面团装。</p>
<p>4.往3中产物里以此加3个鸡蛋，用蛋抽搅至面糊状。</p>
<p>5.将4中产物用裱花袋挤入烤盘，”一坨“就是一个泡芙。</p>
<p>6.将1中冷冻后的产物切片，每一个泡芙上放一片。</p>
<p>7.将烤盘送入烤箱。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>应该要掌握的STL</title>
    <url>/2023/07/12/%E5%BA%94%E8%AF%A5%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84STL/</url>
    <content><![CDATA[<h3 id="应该要掌握的stl">应该要掌握的STL</h3>
<h4 id="vector">1. vector</h4>
<p>​ 假设我们有一个<code>vector&lt;typename&gt;</code>
变量<code>v</code>，那么我们就可以有如下操作：</p>
<ul>
<li><p><code>v.push_back(obj)</code>，可以在<code>v</code>的最后插入一个<code>obj</code></p></li>
<li><p><code>v.pop_back()</code>可以弹出<code>v</code>最后一个元素</p></li>
<li><p><code>v.size()</code>可以返回<code>v</code>中元素的个数</p></li>
<li><p>可以直接通过<code>v[i]</code>访问<code>vector</code>中的元素
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); i++)</span><br><span class="line">    #可以直接用v[i]访问vector中的元素</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sort(v.begin(),v.end(),cmp)</code>可以对<code>v</code>进行排序</p></li>
<li><p><code>v.clear()</code>清空<code>vector v</code></p></li>
</ul>
<h4
id="priority_queue优先队列即堆默认大根堆">2.priority_queue（优先队列，即堆，默认大根堆）</h4>
<p>​
假设我们有一个<code>priority_queue&lt;node&gt;</code>变量<code>heap</code>，那么我们就可以有如下操作：</p>
<ul>
<li><p><code>heap.push(obj)</code>可以把一个元素加入堆</p></li>
<li><p><code>heap.pop()</code>可以弹出堆顶元素</p></li>
<li><p><code>node tmp = heap.top()</code>可以获得堆顶元素</p></li>
<li><p>自定义结构体类型的重载运算符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x,id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp;a, <span class="type">const</span> node &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x; <span class="comment">//以x为关键字从大到小实现大根堆</span></span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x; <span class="comment">//以x为关键字从小到大实现小根堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4
id="lower_bound-upper_bound可以对数组和vector-注意需要事先排序">3.lower_bound
&amp; upper_bound（可以对数组和<em>vector</em>
）（注意需要事先排序）</h4>
<ul>
<li><p><code>int tmp1 = lower_bound(a + 1,a + n + 1,obj) - a</code>返回数组<code>a</code>中第一个<strong>大于等于</strong><code>obj</code>的元素的下标</p></li>
<li><p><code>int tmp2 = upper_bound(a + 1,a + n + 1,obj) - a</code>返回数组<code>a</code>中第一个<strong>大于</strong><code>obj</code>的元素的下标。</p></li>
<li><p><code>int tmp1 = lower_bound(v.begin(),v.end(),obj) - v.begin()</code>返回数组<code>a</code>中第一个<strong>大于等于</strong><code>obj</code>的元素的下标</p></li>
<li><p><code>int tmp1 = upper_bound(v.begin(),v.end(),obj) - v.begin()</code>返回数组<code>a</code>中第一个<strong>大于</strong><code>obj</code>的元素的下标</p></li>
</ul>
<h4 id="unqiue-可以对数组和vector-注意需要事先排序">4.unqiue
(可以对数组和<em>vector</em>) （注意需要事先排序）</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>,a + <span class="number">7</span>);</span><br><span class="line"><span class="type">int</span> m = <span class="built_in">unique</span>(a + <span class="number">1</span>,a + <span class="number">7</span>) - a - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;m = %d\n&quot;</span>,m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[i]);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m = 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h4 id="bitset">5.bitset</h4>
<ul>
<li>新建一个长度为30的<code>bitset</code>并给它赋值为<code>a</code>：
<code>bitset&lt;30&gt; s(a);</code></li>
<li>可以直接用<code>s[i]</code>访问这个<code>bitset</code>，既可以取值，也可以修改。注意：<code>s[0]</code>是最低位，<code>s[29]</code>是最高位。</li>
<li>可以把两个<code>bitset</code>互相做位运算，也可以对两个<code>bitset</code>做<code>==</code>
<code>!=</code> 的比较，还可以对<code>bitset</code>进行左移右移。</li>
<li><code>s.count()</code>返回有几个<code>1</code></li>
<li>如果<code>s</code>所有位全部是<code>0</code>，那么<code>s.any()</code>返回<code>False</code>，<code>s.none()</code>返回<code>True</code></li>
<li>如果<code>s</code>至少有一位是<code>1</code>，那么<code>s.any()</code>返回<code>True</code>，<code>s.none()</code>返回<code>False</code></li>
<li>一个使用实例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = <span class="number">20</span>;</span><br><span class="line"><span class="function">bitset&lt;20&gt; <span class="title">s</span><span class="params">(a)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：<code>s[0]</code>的类型不是<code>int</code>，但可以强制转换为<code>int</code>，所以可以这样<code>int tmp = s[0]</code>，但不能<code>printf("%d\n",s[0])</code>，如果要直接<code>printf</code>，那么应该<code>printf("%d\n",(int)s[0])</code>.</li>
</ul>
<h4 id="multisetset">6. multiset/set</h4>
<blockquote>
<p>所有multiset的操作只要把“multiset”换成”set"就可以了，故下面用multiset演示</p>
</blockquote>
<ul>
<li><p>声明方式：<code>multiset&lt;int&gt; s</code>
或<code>multiset&lt;node&gt; s;</code></p>
<p>​
注意，如果用了后者，那么需要重载<code>&lt;</code>运算符，重载方法和前面在<code>priority_queue</code>里面重载的方法一样。然后，<code>set</code>和<code>multiset</code>默认都是从小到大排序的，所以如果要按照<code>node</code>里的<code>x</code>关键字排序，重载函数应该这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp;a, <span class="type">const</span> node &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>multiset</code>的迭代器的概念：</p>
<ul>
<li>声明一个<code>multiset</code>的迭代器：<code>multiset&lt;node&gt;::iterator it;</code></li>
<li><code>multiset</code>的迭代器仅支持<code>++</code>和<code>--</code>两个操作，分别表示在<code>multiset</code>中向后或者向前一个元素</li>
<li>如果我们有一个<code>multiset</code>的迭代器<code>it</code>，可以通过<code>*it</code>来表示迭代器<code>it</code>指向的元素（有点像一个指针）</li>
</ul></li>
</ul>
<hr />
<p>假设我们有一个<code>multiset&lt;int&gt; s;</code></p>
<ul>
<li><p><code>s.size(), s.erase(), s.clear()</code>均支持。</p></li>
<li><p><code>s.insert(obj)</code>可以实现往里面插入元素的功能</p></li>
<li><p><code>s.find(obj)</code>可以返回一个<code>multiset</code>的迭代器，如果找不到对应元素那么就会返回<code>s.end()</code>，否则返回对应元素的迭代器，可以通过<code>*</code>运算得到对应元素。</p></li>
<li><p>设<code>it</code>是一个<code>multiset</code>的迭代器，那么<code>s.erase(it)</code>可以删除这个迭代器对应的元素。</p></li>
<li><p><code>s.erase(obj)</code>可以删除所有对应元素。</p></li>
<li><p><code>s.count(obj)</code>可以返回<code>s</code>中有多少个元素等于<code>obj</code></p></li>
<li><p><code>s.lower_bound(obj)</code>可以返回第一个大于等于<code>obj</code>的元素的迭代器</p>
<p><code>s.upper_bound(obj)</code>可以返回第一个大于<code>obj</code>的元素的迭代器</p></li>
</ul>
<hr />
<ul>
<li><p>可以通过这个方式输出<code>multiset s</code>中的元素（默认是从小到大排序的）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (multiset&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*it);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="pair">7. pair</h4>
<ul>
<li><p>声明方法：<code>pair&lt;typename1,typename2&gt; tmp;</code></p>
<p>例如：<code>pair&lt;pair&lt;int,int&gt;, vector&lt;int&gt; &gt; tmp;</code></p></li>
<li><p>一种构造方法：<code>pair&lt;int, int&gt; p = make_pair(2,3)</code></p></li>
<li><p>假设我们有一个<code>pair&lt;int, int&gt; p;</code>
那么可以通过<code>p.first</code>和<code>p.second</code>分别访问第一个元素和第二个元素。</p></li>
</ul>
<h4 id="map">8. map</h4>
<ul>
<li><code>map</code>也有<code>insert(), clear(), empty()</code>的操作</li>
</ul>
<p>假设我们有一个<code>map&lt;int,int&gt; mp;</code>和一个<code>map&lt;int,int&gt;::iterator it;</code>
-
往<code>map</code>里插入一个键值对：<code>mp.insert(make_pair(2,3))</code></p>
<ul>
<li><p>删除迭代器<code>it</code>对应的元素：<code>mp.erase(it)</code></p></li>
<li><p>删除<code>map</code>中的<code>pair</code>：<code>mp.erase(make_pair(2,3))</code></p></li>
<li><p>通过<code>key</code>来删除<code>map</code>中的<code>pair</code>：
<code>mp.erase(2)</code></p></li>
<li><p><code>mp.find(make_pair(2,3))</code>在<code>m</code>中找对应元素，返回迭代器。如果不存在，返回<code>mp.end()</code></p></li>
<li><p><code>mp[key]</code>返回<code>key</code>值对应的<code>value</code>，可以直接赋值或访问（和python里的字典一样），如果不存在<code>mp[key]</code>，则直接新建一个空二元组<code>(key,zero)</code></p></li>
</ul>
]]></content>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>拉格朗日乘数法复习</title>
    <url>/2025/05/04/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%95%B0%E6%B3%95/</url>
    <content><![CDATA[<h3 id="拉格朗日乘数法复习">拉格朗日乘数法复习</h3>
<p><span class="math inline">\(\hspace{1cm}\)</span>
给定一个多元函数<span class="math inline">\(f(\mathbf{x})\)</span>,
和若干个限制：<span class="math inline">\(g_1(\mathbf{x}) =
g_2(\mathbf{x}) = ... = g_m(\mathbf{x}) = 0\)</span>, 求<span
class="math inline">\(f(\mathbf{x})\)</span>的最小值。这里的<span
class="math inline">\(\mathbf{x}\)</span>是一个向量。<span
class="math inline">\(\mathbf{x} = \{x_1,x_2,...x_n\}\)</span></p>
<p><span class="math inline">\(\hspace{1cm}\)</span> 设<span
class="math inline">\(L(\mathbf{x}, \lambda_1, \lambda_2, ...,
\lambda_m) = f(\mathbf{x}) - \lambda_1g_1(\mathbf{x}) - ... -
\lambda_mg_m(\mathbf{x})\)</span>,若<span
class="math inline">\(\frac{\partial L}{\partial \mathbf{x}} =
\mathbf{0}\)</span>，<span class="math inline">\(\forall i \in
[1,m],\frac{\partial L}{\partial \lambda_i} = 0\)</span>, 则此时的<span
class="math inline">\(\mathbf{x}\)</span>是一个候选的极小值点（极小值点必定在这样的一个<span
class="math inline">\(\mathbf{x}\)</span>中）</p>
<p>证明：</p>
<p><span class="math inline">\(\hspace{1cm}\)</span> 考虑<span
class="math inline">\(\mathbf{x} = \mathbf{x_0}\)</span>时，此时<span
class="math inline">\(\mathbf{x}\)</span>想要有任何的微小位移<span
class="math inline">\(\Delta \mathbf{x}\)</span>,都必须满足： <span
class="math display">\[
\Delta \mathbf{x} \cdot \nabla g_i(\mathbf{x_0}) = 0 \ \ \ \forall i
\in[1,m]
\]</span> <span class="math inline">\(\hspace{1cm}\)</span>
我们称任意一个满足上式的微小位移<span class="math inline">\(\Delta
\mathbf{x}\)</span>为合法微小位移。</p>
<p><span class="math inline">\(\hspace{1cm}\)</span> 若<span
class="math inline">\(\mathbf{x_0}\)</span>还是一个最小值点，那么对于<strong>任意</strong>一个合法微小位移，它肯定需要满足：
<span class="math display">\[
\Delta \mathbf{x} \cdot \nabla f(\mathbf{x_0}) = 0
\]</span> <span class="math inline">\(\hspace{1cm}\)</span>
因为对于<strong>任意</strong>一个合法微小位移都需要满足，所以显然<span
class="math inline">\(\nabla f(\mathbf{x_0})\)</span>必定在<span
class="math inline">\(\nabla
g_i(\mathbf{x_0})\)</span>张成的线性空间里。这就对应：<span
class="math inline">\(\frac{\partial L}{\partial \mathbf{x}} =
\mathbf{0}\)</span>的这个条件。至于<span class="math inline">\(\forall i
\in [1,m],\frac{\partial L}{\partial \lambda_i} =
0\)</span>，这是为了满足约束条件而显然必须的条件。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
</search>
